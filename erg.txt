BASH=/usr/bin/bash
BASHOPTS=checkwinsize:cmdhist:complete_fullquote:expand_aliases:extglob:extquote:force_fignore:globasciiranges:globskipdots:histappend:interactive_comments:patsub_replacement:progcomp:promptvars:sourcepath
BASHRCSOURCED=Y
BASH_ALIASES=()
BASH_ARGC=([0]="0")
BASH_ARGV=()
BASH_CMDS=()
BASH_COMPLETION_VERSINFO=([0]="2" [1]="13" [2]="0")
BASH_LINENO=()
BASH_LOADABLES_PATH=/usr/local/lib/bash:/usr/lib/bash:/opt/local/lib/bash:/usr/pkg/lib/bash:/opt/pkg/lib/bash:.
BASH_REMATCH=()
BASH_SOURCE=()
BASH_VERSINFO=([0]="5" [1]="2" [2]="32" [3]="1" [4]="release" [5]="x86_64-redhat-linux-gnu")
BASH_VERSION='5.2.32(1)-release'
COLORTERM=truecolor
COLUMNS=152
COMP_FILEDIR_FALLBACK=BASH_COMPLETION_FILEDIR_FALLBACK
COMP_KNOWN_HOSTS_WITH_AVAHI=BASH_COMPLETION_KNOWN_HOSTS_WITH_AVAHI
COMP_KNOWN_HOSTS_WITH_HOSTFILE=BASH_COMPLETION_KNOWN_HOSTS_WITH_HOSTFILE
COMP_WORDBREAKS=$' \t\n"\'><=;|&(:'
DBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/1000/bus
DEBUGINFOD_IMA_CERT_PATH=/etc/keys/ima:
DEBUGINFOD_URLS='https://debuginfod.fedoraproject.org/ '
DESKTOP_SESSION=gnome-classic
DIRSTACK=()
DISPLAY=:0
EDITOR=/usr/bin/nano
EUID=1000
GDMSESSION=gnome-classic
GDM_LANG=de_DE.UTF-8
GNOME_SETUP_DISPLAY=:1
GNOME_SHELL_SESSION_MODE=classic
GNOME_TERMINAL_SCREEN=/org/gnome/Terminal/screen/890f886d_9bc0_481a_9dd2_bd54f42ba909
GNOME_TERMINAL_SERVICE=:1.100
GPG_TTY=/dev/pts/4
GROUPS=()
HISTCONTROL=ignoredups
HISTFILE=/home/ernst/.bash_history
HISTFILESIZE=1000
HISTSIZE=1000
HOME=/home/ernst
HOSTNAME=fedora.fritz.box
HOSTTYPE=x86_64
IFS=$' \t\n'
LANG=de_DE.UTF-8
LESSOPEN='||/usr/bin/lesspipe.sh %s'
LINES=24
LOGNAME=ernst
LS_COLORS='rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=01;37;41:su=37;41:sg=30;43:ca=00:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.7z=01;31:*.ace=01;31:*.alz=01;31:*.apk=01;31:*.arc=01;31:*.arj=01;31:*.bz=01;31:*.bz2=01;31:*.cab=01;31:*.cpio=01;31:*.crate=01;31:*.deb=01;31:*.drpm=01;31:*.dwm=01;31:*.dz=01;31:*.ear=01;31:*.egg=01;31:*.esd=01;31:*.gz=01;31:*.jar=01;31:*.lha=01;31:*.lrz=01;31:*.lz=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.lzo=01;31:*.pyz=01;31:*.rar=01;31:*.rpm=01;31:*.rz=01;31:*.sar=01;31:*.swm=01;31:*.t7z=01;31:*.tar=01;31:*.taz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tgz=01;31:*.tlz=01;31:*.txz=01;31:*.tz=01;31:*.tzo=01;31:*.tzst=01;31:*.udeb=01;31:*.war=01;31:*.whl=01;31:*.wim=01;31:*.xz=01;31:*.z=01;31:*.zip=01;31:*.zoo=01;31:*.zst=01;31:*.avif=01;35:*.jpg=01;35:*.jpeg=01;35:*.mjpg=01;35:*.mjpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.webp=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=01;36:*.au=01;36:*.flac=01;36:*.m4a=01;36:*.mid=01;36:*.midi=01;36:*.mka=01;36:*.mp3=01;36:*.mpc=01;36:*.ogg=01;36:*.ra=01;36:*.wav=01;36:*.oga=01;36:*.opus=01;36:*.spx=01;36:*.xspf=01;36:*~=00;90:*#=00;90:*.bak=00;90:*.crdownload=00;90:*.dpkg-dist=00;90:*.dpkg-new=00;90:*.dpkg-old=00;90:*.dpkg-tmp=00;90:*.old=00;90:*.orig=00;90:*.part=00;90:*.rej=00;90:*.rpmnew=00;90:*.rpmorig=00;90:*.rpmsave=00;90:*.swp=00;90:*.tmp=00;90:*.ucf-dist=00;90:*.ucf-new=00;90:*.ucf-old=00;90:'
MACHTYPE=x86_64-redhat-linux-gnu
MAIL=/var/spool/mail/ernst
MAILCHECK=60
MEMORY_PRESSURE_WATCH=/sys/fs/cgroup/user.slice/user-1000.slice/user@1000.service/session.slice/org.gnome.Shell@wayland.service/memory.pressure
MEMORY_PRESSURE_WRITE=c29tZSAyMDAwMDAgMjAwMDAwMAA=
MOZ_GMP_PATH=/usr/lib64/mozilla/plugins/gmp-gmpopenh264/system-installed
OLDPWD=/home/ernst
OPTERR=1
OPTIND=1
OSTYPE=linux-gnu
PATH=/home/ernst/.pyenv/plugins/pyenv-virtualenv/shims:/home/ernst/.pyenv/shims:/home/ernst/.pyenv/bin:/home/ernst/.pyenv/plugins/pyenv-virtualenv/shims:/home/ernst/.pyenv/bin:/home/ernst/.local/bin:/home/ernst/bin:/usr/local/bin:/usr/local/sbin:/usr/bin:/usr/sbin
PIPESTATUS=([0]="0")
PPID=13665
PROMPT_COLOR=32
PROMPT_COMMAND=([0]="printf \"\\033]0;%s@%s:%s\\007\" \"\${USER}\" \"\${HOSTNAME%%.*}\" \"\${PWD/#\$HOME/\\~}\"" [1]="__vte_precmd" [2]="__vte_osc7")
PROMPT_DIRECTORY='\w'
PROMPT_SEPARATOR=:
PROMPT_USERHOST='\u@\h'
PS0=$'\\e]133;C\\e\\\\\\r\E]666;vte.shell.preexec!\E\\'
PS1='\[\e]133;D;$?\e\\\e]133;A\e\\\]${PROMPT_START@P}\[\e[${PROMPT_COLOR}${PROMPT_HIGHLIGHT:+;$PROMPT_HIGHLIGHT}m\]${PROMPT_USERHOST@P}\[\e[0m\]${PROMPT_SEPARATOR@P}\[\e[${PROMPT_DIR_COLOR-${PROMPT_COLOR}}${PROMPT_HIGHLIGHT:+;$PROMPT_HIGHLIGHT}m\]${PROMPT_DIRECTORY@P}\[\e[0m\]${PROMPT_END@P}\$\[\e[0m\] \[\e]133;B\e\\\]'
PS2='> '
PS4='+ '
PWD=/home/ernst/Devel/heating
PYENV_ROOT=/home/ernst/.pyenv
PYENV_SHELL=bash
PYENV_VIRTUALENV_INIT=1
QT_IM_MODULE=ibus
SESSION_MANAGER=local/unix:@/tmp/.ICE-unix/12717,unix/unix:/tmp/.ICE-unix/12717
SHELL=/bin/bash
SHELLOPTS=braceexpand:emacs:hashall:histexpand:history:interactive-comments:monitor
SHLVL=1
SSH_AGENT_PID=2782
SSH_AUTH_SOCK=/run/user/1000/keyring/ssh
SYSTEMD_EXEC_PID=12765
SYSTEMD_SLEEP_FREEZE_USER_SESSIONS=0
TERM=xterm-256color
UID=1000
USER=ernst
USERNAME=ernst
VTE_VERSION=7800
WAYLAND_DISPLAY=wayland-0
XAUTHORITY=/run/user/1000/.mutter-Xwaylandauth.U7ZFX2
XDG_CURRENT_DESKTOP=GNOME-Classic:GNOME
XDG_DATA_DIRS=/home/ernst/.local/share/flatpak/exports/share:/var/lib/flatpak/exports/share:/usr/local/share/:/usr/share/
XDG_MENU_PREFIX=gnome-
XDG_RUNTIME_DIR=/run/user/1000
XDG_SESSION_CLASS=user
XDG_SESSION_DESKTOP=gnome-classic
XDG_SESSION_TYPE=wayland
XMODIFIERS=@im=ibus
_=set
_backup_glob='@(#*#|*@(~|.@(bak|orig|rej|swp|@(dpkg|ucf)-*|rpm@(orig|new|save))))'
_comp_backup_glob='@(#*#|*@(~|.@(bak|orig|rej|swp|@(dpkg|ucf)-*|rpm@(orig|new|save))))'
_comp_dequote__regex_safe_word='^([^\'\''"$`;&|<>()!]|\\.|'\''[^'\'']*'\''|\$?"([^\"$`!]|\$([_a-zA-Z][_a-zA-Z0-9]*|[-*@#?$!0-9_])|\$\{[!#]?([_a-zA-Z][_a-zA-Z0-9]*(\[([0-9]+|[*@])\])?|[-*@#?$!0-9_])\}|\\.)*"|\$'\''([^\'\'']|\\.)*'\''|\$([_a-zA-Z][_a-zA-Z0-9]*|[-*@#?$!0-9_])|\$\{[!#]?([_a-zA-Z][_a-zA-Z0-9]*(\[([0-9]+|[*@])\])?|[-*@#?$!0-9_])\})*$'
_comp_xspecs=([tex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [freeamp]="!*.@(mp3|ogg|pls|m3u)" [gqmpeg]="!*.@(mp3|ogg|pls|m3u)" [texi2html]="!*.texi*" [hbpp]="!*.@([Pp][Rr][Gg]|[Cc][Ll][Pp])" [lowriter]="!*.@(sxw|stw|sxg|sgl|doc?([mx])|dot?([mx])|rtf|txt|htm|html|?(f)odt|ott|odm|pdf)" [rpm2cpio]="!*.[rs]pm" [localc]="!*.@(sxc|stc|xls?([bmx])|xlw|xlt?([mx])|[ct]sv|?(f)ods|ots)" [hbrun]="!*.[Hh][Rr][Bb]" [vi]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [latex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [view]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [madplay]="!*.mp3" [compress]="*.Z" [pdfjadetex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [pbunzip2]="!*.?(t)bz?(2)" [lrunzip]="!*.lrz" [gunzip]="!*.@(Z|[gGd]z|t[ag]z)" [oowriter]="!*.@(sxw|stw|sxg|sgl|doc?([mx])|dot?([mx])|rtf|txt|htm|html|?(f)odt|ott|odm|pdf)" [epiphany]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [acroread]="!*.[pf]df" [znew]="*.Z" [kwrite]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [xemacs]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [gview]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [lzfgrep]="!*.@(tlz|lzma)" [lzless]="!*.@(tlz|lzma)" [cdiff]="!*.@(dif?(f)|?(d)patch)?(.@([gx]z|bz2|lzma))" [zipinfo]="!*.@(zip|[aegjkswx]ar|exe|pk3|wsz|zargo|xpi|s[tx][cdiw]|sx[gm]|o[dt][tspgfc]|od[bm]|oxt|?(o)xps|epub|cbz|apk|aab|ipa|do[ct][xm]|p[op]t[mx]|xl[st][xm]|pyz|whl|[Ff][Cc][Ss]td)" [pdflatex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [portecle]="!@(*.@(ks|jks|jceks|p12|pfx|bks|ubr|gkr|cer|crt|cert|p7b|pkipath|pem|p10|csr|crl)|cacerts)" [modplugplay]="!*.@(669|abc|am[fs]|d[bs]m|dmf|far|it|mdl|m[eo]d|mid?(i)|mt[2m]|oct|okt?(a)|p[st]m|s[3t]m|ult|umx|wav|xm)" [lokalize]="!*.po" [lbzcat]="!*.?(t)bz?(2)" [qiv]="!*.@(gif|jp?(e)g|tif?(f)|png|p[bgp]m|bmp|x[bp]m|rle|rgb|pcx|fits|pm|svg)" [totem]="!*@(.@(mp?(e)g|MP?(E)G|wm[av]|WM[AV]|avi|AVI|asf|vob|VOB|bin|dat|divx|DIVX|vcd|ps|pes|fli|flv|FLV|fxm|FXM|viv|rm|ram|yuv|mov|MOV|qt|QT|web[am]|WEB[AM]|mp[234]|MP[234]|m?(p)4[av]|M?(P)4[AV]|mkv|MKV|og[agmv]|OG[AGMV]|opus|OPUS|t[ps]|T[PS]|m2t?(s)|M2T?(S)|mts|MTS|wav|WAV|flac|FLAC|asx|ASX|mng|MNG|srt|m[eo]d|M[EO]D|s[3t]m|S[3T]M|it|IT|xm|XM|iso|ISO)|+([0-9]).@(vdr|VDR))?(.@(crdownload|part))" [ps2pdfwr]="!*.@(?(e)ps|pdf)" [dvitype]="!*.dvi" [unpigz]="!*.@(Z|[gGdz]z|t[ag]z)" [mozilla]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [pdfunite]="!*.pdf" [gpdf]="!*.[pf]df" [texi2dvi]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [bunzip2]="!*.?(t)bz?(2)" [zathura]="!*.@(cb[rz7t]|djv?(u)|?(e)ps|pdf)" [kaffeine]="!*@(.@(mp?(e)g|MP?(E)G|wm[av]|WM[AV]|avi|AVI|asf|vob|VOB|bin|dat|divx|DIVX|vcd|ps|pes|fli|flv|FLV|fxm|FXM|viv|rm|ram|yuv|mov|MOV|qt|QT|web[am]|WEB[AM]|mp[234]|MP[234]|m?(p)4[av]|M?(P)4[AV]|mkv|MKV|og[agmv]|OG[AGMV]|opus|OPUS|t[ps]|T[PS]|m2t?(s)|M2T?(S)|mts|MTS|wav|WAV|flac|FLAC|asx|ASX|mng|MNG|srt|m[eo]d|M[EO]D|s[3t]m|S[3T]M|it|IT|xm|XM|iso|ISO)|+([0-9]).@(vdr|VDR))?(.@(crdownload|part))" [mpg123]="!*.mp3" [lzegrep]="!*.@(tlz|lzma)" [xv]="!*.@(gif|jp?(e)g?(2)|j2[ck]|jp[2f]|tif?(f)|png|p[bgp]m|bmp|x[bp]m|rle|rgb|pcx|fits|pm|?(e)ps)" [xdvi]="!*.@(dvi|DVI)?(.@(gz|Z|bz2))" [xfig]="!*.fig" [xpdf]="!*.[pf]df" [oobase]="!*.odb" [xelatex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [gharbour]="!*.@([Pp][Rr][Gg]|[Cc][Ll][Pp])" [bzcat]="!*.?(t)bz?(2)" [dragon]="!*@(.@(mp?(e)g|MP?(E)G|wm[av]|WM[AV]|avi|AVI|asf|vob|VOB|bin|dat|divx|DIVX|vcd|ps|pes|fli|flv|FLV|fxm|FXM|viv|rm|ram|yuv|mov|MOV|qt|QT|web[am]|WEB[AM]|mp[234]|MP[234]|m?(p)4[av]|M?(P)4[AV]|mkv|MKV|og[agmv]|OG[AGMV]|opus|OPUS|t[ps]|T[PS]|m2t?(s)|M2T?(S)|mts|MTS|wav|WAV|flac|FLAC|asx|ASX|mng|MNG|srt|m[eo]d|M[EO]D|s[3t]m|S[3T]M|it|IT|xm|XM|iso|ISO)|+([0-9]).@(vdr|VDR))?(.@(crdownload|part))" [xanim]="!*.@(mpg|mpeg|avi|mov|qt)" [lualatex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [rgview]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [rvim]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [xetex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [lomath]="!*.@(sxm|smf|mml|odf)" [zcat]="!*.@(Z|[gGd]z|t[ag]z)" [lynx]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [uncompress]="!*.Z" [xzcat]="!*.@(?(t)xz|tlz|lzma)" [vim]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [loimpress]="!*.@(sxi|sti|pps?(x)|ppt?([mx])|pot?([mx])|?(f)odp|otp)" [dvipdf]="!*.dvi" [mpg321]="!*.mp3" [jadetex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [lobase]="!*.odb" [epdfview]="!*.pdf" [ps2pdf14]="!*.@(?(e)ps|pdf)" [ps2pdf13]="!*.@(?(e)ps|pdf)" [ps2pdf12]="!*.@(?(e)ps|pdf)" [poedit]="!*.po" [luatex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [kbabel]="!*.po" [bzme]="!*.@(zip|z|gz|tgz)" [dviselect]="!*.dvi" [realplay]="!*.@(rm?(j)|ra?(m)|smi?(l))" [kdvi]="!*.@(dvi|DVI)?(.@(gz|Z|bz2))" [elinks]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [kghostview]="!*.@(@(?(e)ps|?(E)PS|pdf|PDF)?(.gz|.GZ|.bz2|.BZ2|.Z))" [gtranslator]="!*.po" [unzip]="!*.@(zip|[aegjkswx]ar|exe|pk3|wsz|zargo|xpi|s[tx][cdiw]|sx[gm]|o[dt][tspgfc]|od[bm]|oxt|?(o)xps|epub|cbz|apk|aab|ipa|do[ct][xm]|p[op]t[mx]|xl[st][xm]|pyz|whl|[Ff][Cc][Ss]td)" [ggv]="!*.@(@(?(e)ps|?(E)PS|pdf|PDF)?(.gz|.GZ|.bz2|.BZ2|.Z))" [oomath]="!*.@(sxm|smf|mml|odf)" [dvipdfmx]="!*.dvi" [makeinfo]="!*.texi*" [okular]="!*.@(okular|@(?(e|x)ps|?(E|X)PS|[pf]df|[PF]DF|dvi|DVI|cb[rz]|CB[RZ]|djv?(u)|DJV?(U)|dvi|DVI|gif|jp?(e)g|miff|tif?(f)|pn[gm]|p[bgp]m|bmp|xpm|ico|xwd|tga|pcx|GIF|JP?(E)G|MIFF|TIF?(F)|PN[GM]|P[BGP]M|BMP|XPM|ICO|XWD|TGA|PCX|epub|EPUB|odt|ODT|fb?(2)|FB?(2)|mobi|MOBI|g3|G3|chm|CHM|md|markdown)?(.?(gz|GZ|bz2|BZ2|xz|XZ)))" [cacaxine]="!*@(.@(mp?(e)g|MP?(E)G|wm[av]|WM[AV]|avi|AVI|asf|vob|VOB|bin|dat|divx|DIVX|vcd|ps|pes|fli|flv|FLV|fxm|FXM|viv|rm|ram|yuv|mov|MOV|qt|QT|web[am]|WEB[AM]|mp[234]|MP[234]|m?(p)4[av]|M?(P)4[AV]|mkv|MKV|og[agmv]|OG[AGMV]|t[ps]|T[PS]|m2t?(s)|M2T?(S)|mts|MTS|wav|WAV|flac|FLAC|asx|ASX|mng|MNG|srt|m[eo]d|M[EO]D|s[3t]m|S[3T]M|it|IT|xm|XM)|+([0-9]).@(vdr|VDR))?(.@(crdownload|part))" [sxemacs]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [aviplay]="!*.@(avi|asf|wmv)" [rgvim]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [dvipdfm]="!*.dvi" [ly2dvi]="!*.ly" [oodraw]="!*.@(sxd|std|sda|sdd|?(f)odg|otg)" [kpdf]="!*.@(?(e)ps|pdf)" [bibtex]="!*.aux" [netscape]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [emacs]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [rview]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [galeon]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [dillo]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [fbxine]="!*@(.@(mp?(e)g|MP?(E)G|wm[av]|WM[AV]|avi|AVI|asf|vob|VOB|bin|dat|divx|DIVX|vcd|ps|pes|fli|flv|FLV|fxm|FXM|viv|rm|ram|yuv|mov|MOV|qt|QT|web[am]|WEB[AM]|mp[234]|MP[234]|m?(p)4[av]|M?(P)4[AV]|mkv|MKV|og[agmv]|OG[AGMV]|t[ps]|T[PS]|m2t?(s)|M2T?(S)|mts|MTS|wav|WAV|flac|FLAC|asx|ASX|mng|MNG|srt|m[eo]d|M[EO]D|s[3t]m|S[3T]M|it|IT|xm|XM)|+([0-9]).@(vdr|VDR))?(.@(crdownload|part))" [oocalc]="!*.@(sxc|stc|xls?([bmx])|xlw|xlt?([mx])|[ct]sv|?(f)ods|ots)" [harbour]="!*.@([Pp][Rr][Gg]|[Cc][Ll][Pp])" [lodraw]="!*.@(sxd|std|sda|sdd|?(f)odg|otg)" [dvips]="!*.dvi" [ps2pdf]="!*.@(?(e)ps|pdf)" [kate]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [kid3-qt]="!*.@(mp[234c]|og[ag]|@(fl|a)ac|m4[abp]|spx|tta|w?(a)v|wma|aif?(f)|asf|ape)" [pdftex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [gvim]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [timidity]="!*.@(mid?(i)|rmi|rcp|[gr]36|g18|mod|xm|it|x3m|s[3t]m|kar)" [ogg123]="!*.@(og[ag]|m3u|flac|spx)" [lzgrep]="!*.@(tlz|lzma)" [ee]="!*.@(gif|jp?(e)g|miff|tif?(f)|pn[gm]|p[bgp]m|bmp|xpm|ico|xwd|tga|pcx)" [unlzma]="!*.@(tlz|lzma)" [lbunzip2]="!*.?(t)bz?(2)" [ooimpress]="!*.@(sxi|sti|pps?(x)|ppt?([mx])|pot?([mx])|?(f)odp|otp)" [xine]="!*@(.@(mp?(e)g|MP?(E)G|wm[av]|WM[AV]|avi|AVI|asf|vob|VOB|bin|dat|divx|DIVX|vcd|ps|pes|fli|flv|FLV|fxm|FXM|viv|rm|ram|yuv|mov|MOV|qt|QT|web[am]|WEB[AM]|mp[234]|MP[234]|m?(p)4[av]|M?(P)4[AV]|mkv|MKV|og[agmv]|OG[AGMV]|t[ps]|T[PS]|m2t?(s)|M2T?(S)|mts|MTS|wav|WAV|flac|FLAC|asx|ASX|mng|MNG|srt|m[eo]d|M[EO]D|s[3t]m|S[3T]M|it|IT|xm|XM)|+([0-9]).@(vdr|VDR))?(.@(crdownload|part))" [amaya]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [gv]="!*.@(@(?(e)ps|?(E)PS|pdf|PDF)?(.gz|.GZ|.bz2|.BZ2|.Z))" [kid3]="!*.@(mp[234c]|og[ag]|@(fl|a)ac|m4[abp]|spx|tta|w?(a)v|wma|aif?(f)|asf|ape)" [lilypond]="!*.ly" [modplug123]="!*.@(669|abc|am[fs]|d[bs]m|dmf|far|it|mdl|m[eo]d|mid?(i)|mt[2m]|oct|okt?(a)|p[st]m|s[3t]m|ult|umx|wav|xm)" [pbzcat]="!*.?(t)bz?(2)" [unxz]="!*.@(?(t)xz|tlz|lzma)" [playmidi]="!*.@(mid?(i)|cmf)" [lzcat]="!*.@(tlz|lzma)" [slitex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [aaxine]="!*@(.@(mp?(e)g|MP?(E)G|wm[av]|WM[AV]|avi|AVI|asf|vob|VOB|bin|dat|divx|DIVX|vcd|ps|pes|fli|flv|FLV|fxm|FXM|viv|rm|ram|yuv|mov|MOV|qt|QT|web[am]|WEB[AM]|mp[234]|MP[234]|m?(p)4[av]|M?(P)4[AV]|mkv|MKV|og[agmv]|OG[AGMV]|t[ps]|T[PS]|m2t?(s)|M2T?(S)|mts|MTS|wav|WAV|flac|FLAC|asx|ASX|mng|MNG|srt|m[eo]d|M[EO]D|s[3t]m|S[3T]M|it|IT|xm|XM)|+([0-9]).@(vdr|VDR))?(.@(crdownload|part))" [advi]="!*.dvi" [lzmore]="!*.@(tlz|lzma)" )
colors=/home/ernst/.dircolors
__expand_tilde_by_ref () 
{ 
    [[ -n ${1+set} ]] || return 0;
    [[ $1 == REPLY ]] || local REPLY;
    _comp_expand_tilde "${!1-}";
    [[ $1 == REPLY ]] || printf -v "$1" "$REPLY"
}
__load_completion () 
{ 
    _comp_load "$@"
}
__ltrim_colon_completions () 
{ 
    _comp_ltrim_colon_completions "$@"
}
__parse_options () 
{ 
    local -a _options=();
    _comp_compgen_help__parse "$1";
    printf '%s\n' "${_options[@]}"
}
__python_argcomplete_expand_tilde_by_ref () 
{ 
    if [ -n "${ZSH_VERSION-}" ]; then
        if [ "${(P)1[1]}" = "~" ]; then
            eval $1="${(P)1/#\~/$HOME}";
        fi;
    else
        if [ "${!1:0:1}" = "~" ]; then
            if [ "${!1}" != "${!1//\/}" ]; then
                eval $1="${!1/%\/*}"/'${!1#*/}';
            else
                eval $1="${!1}";
            fi;
        fi;
    fi
}
__python_argcomplete_run () 
{ 
    if [[ -z "${ARGCOMPLETE_USE_TEMPFILES-}" ]]; then
        __python_argcomplete_run_inner "$@";
        return;
    fi;
    local tmpfile="$(mktemp)";
    _ARGCOMPLETE_STDOUT_FILENAME="$tmpfile" __python_argcomplete_run_inner "$@";
    local code=$?;
    cat "$tmpfile";
    rm "$tmpfile";
    return $code
}
__python_argcomplete_run_inner () 
{ 
    if [[ -z "${_ARC_DEBUG-}" ]]; then
        "$@" 8>&1 9>&2 > /dev/null 2>&1 < /dev/null;
    else
        "$@" 8>&1 9>&2 1>&9 2>&1 < /dev/null;
    fi
}
__python_argcomplete_scan_head () 
{ 
    local file="$1";
    local target="$2";
    local REPLY;
    if [[ -n "${ZSH_VERSION-}" ]]; then
        read -r -k 1024 -u 0 < "$file";
    else
        read -r -N 1024 < "$file";
    fi;
    if [[ "$target" = "interpreter" ]]; then
        read -r <<< "$REPLY";
    fi;
    local regex;
    case "$target" in 
        magic_string)
            regex='PYTHON_ARGCOMPLETE_OK'
        ;;
        easy_install)
            regex="(PBR Generated)|(EASY-INSTALL-(SCRIPT|ENTRY-SCRIPT|DEV-SCRIPT))"
        ;;
        asdf)
            regex="asdf exec "
        ;;
        interpreter)
            regex='^#!(.*)$'
        ;;
    esac;
    local ret="";
    if [[ "$REPLY" =~ $regex ]]; then
        ret=1;
    fi;
    __python_argcomplete_upshift_bash_rematch;
    [[ -n $ret ]]
}
__python_argcomplete_scan_head_noerr () 
{ 
    __python_argcomplete_scan_head "$@" 2> /dev/null
}
__python_argcomplete_upshift_bash_rematch () 
{ 
    if [[ -z "${ZSH_VERSION-}" ]]; then
        _BASH_REMATCH=("" "${BASH_REMATCH[@]}");
    else
        _BASH_REMATCH=("${BASH_REMATCH[@]}");
    fi
}
__python_argcomplete_which () 
{ 
    if [[ -n "${ZSH_VERSION-}" ]]; then
        whence -p "$@";
    else
        type -P "$@";
    fi
}
__vte_osc7 () 
{ 
    local errsv="$?";
    printf "\033]7;file://%s%s\033\\" "${HOSTNAME}" "$(/usr/libexec/vte-urlencode-cwd)";
    return $errsv
}
__vte_precmd () 
{ 
    local errsv="$?";
    __vte_termprop_set "vte.shell.postexec" "$?";
    __vte_termprop_signal "vte.shell.precmd";
    return $errsv
}
__vte_prompt_command () 
{ 
    local errsv="$?";
    __vte_termprop_set "vte.shell.postexec" "$errsv";
    __vte_osc7;
    local pwd='~';
    [ "$PWD" != "$HOME" ] && pwd=${PWD/#$HOME\//\~\/};
    pwd="${pwd//[[:cntrl:]]}";
    printf "\033]0;%s@%s:%s\033\\" "${USER}" "${HOSTNAME%%.*}" "${pwd}";
    __vte_termprop_signal "vte.shell.precmd";
    return $errsv
}
__vte_termprop_reset () 
{ 
    local errsv="$?";
    printf '\033]666;%s\033\\' "$1";
    return $errsv
}
__vte_termprop_set () 
{ 
    local errsv="$?";
    printf '\033]666;%s=%s\033\\' "$1" "$2";
    return $errsv
}
__vte_termprop_signal () 
{ 
    local errsv="$?";
    printf '\033]666;%s!\033\\' "$1";
    return $errsv
}
_allowed_groups () 
{ 
    _comp_compgen -c "${1:-$cur}" allowed_groups
}
_allowed_users () 
{ 
    _comp_compgen -c "${1:-$cur}" allowed_users
}
_authselect_completions () 
{ 
    local COMMANDS;
    local command;
    local possibleopts;
    function is_valid_command () 
    { 
        local cmd;
        for cmd in "${COMMANDS[@]}";
        do
            if [[ "$cmd" = "$1" ]]; then
                return 0;
            fi;
        done;
        return 1
    };
    function get_command () 
    { 
        local opt;
        if [[ $COMP_CWORD -lt 2 ]]; then
            return;
        fi;
        for opt in "${COMP_WORDS[@]:0:$COMP_CWORD}";
        do
            if is_valid_command "$opt"; then
                echo "$opt";
                return;
            fi;
        done
    };
    function get_command_param () 
    { 
        local havecmd=0;
        local len=${#COMP_WORDS[@]}-1;
        if [[ "$command" = "" ]]; then
            return;
        fi;
        havecmd=0;
        for ((i=0; i<$len; i++ ))
        do
            if [[ "$havecmd" = "1" ]]; then
                if [[ "${COMP_WORDS[$i]}" =~ ^[-=] || "${COMP_WORDS[$i-1]}" = "=" ]]; then
                    continue;
                fi;
                echo "${COMP_WORDS[$i]}";
                return;
            fi;
            if [[ "${COMP_WORDS[$i]}" = "$command" ]]; then
                havecmd=1;
            fi;
        done
    };
    function get_profile () 
    { 
        case "$command" in 
            select | show | requirements | test | list-features)
                get_command_param
            ;;
            enable-feature | disable-feature)
                authselect current 2> /dev/null | head -n1 | cut -d" " -f3
            ;;
        esac
    };
    function get_command_keywords () 
    { 
        local profile;
        case "$command" in 
            select | requirements | test)
                profile="$(get_profile)";
                if [[ "$profile" != "" ]]; then
                    authselect list-features "$profile" 2> /dev/null;
                fi
            ;;
        esac
    };
    function get_command_options () 
    { 
        if [[ "${COMP_WORDS[$COMP_CWORD]}" =~ ^- ]]; then
            case "$command" in 
                select)
                    echo "--force --quiet --nobackup --backup="
                ;;
                apply-changes | disable-feature)
                    echo "--backup="
                ;;
                enable-feature)
                    echo "--backup= --quiet"
                ;;
                current | backup-list)
                    echo "--raw"
                ;;
                create-profile)
                    echo "--vendor --base-on= --base-on-default" "--symlink-meta --symlink-nsswitch --symlink-pam" "--symlink-dconf --symlink="
                ;;
                test)
                    echo "--all --nsswitch --system-auth --password-auth" "--smartcard-auth --fingerprint-auth --postlogin" "--dconf-db --dconf-lock"
                ;;
            esac;
        fi
    };
    function get_global_options () 
    { 
        if [[ "${COMP_WORDS[$COMP_CWORD]}" =~ ^- ]]; then
            echo "--debug --trace --warn --help";
        fi
    };
    function get_option_params () 
    { 
        local opt;
        if [[ $COMP_CWORD -gt 2 && "${COMP_WORDS[$COMP_CWORD-1]}" = "=" ]]; then
            opt="${COMP_WORDS[$COMP_CWORD-2]}";
        else
            if [[ $COMP_CWORD -gt 1 ]]; then
                opt="${COMP_WORDS[$COMP_CWORD-1]}";
            fi;
        fi;
        case "$opt" in 
            --base-on)
                authselect list 2> /dev/null | cut -d" " -f2
            ;;
            --symlink)
                echo "dconf-db dconf-locks fingerprint-auth nsswitch.conf" "password-auth postlogin smartcard-auth system-auth" "README REQUIREMENTS"
            ;;
        esac
    };
    function get_command_params () 
    { 
        local i;
        local profile;
        if [[ "$command" = "" ]]; then
            return;
        fi;
        for ((i=$COMP_CWORD-1; i>1; i-- ))
        do
            opt="${COMP_WORDS[$i]}";
            if [[ "$opt" = "$command" ]]; then
                break;
            fi;
            if [[ "$opt" =~ ^[-=] || "${COMP_WORDS[$i-1]}" = "=" ]]; then
                continue;
            fi;
            return;
        done;
        case "$command" in 
            select | show | requirements | test | list-features)
                authselect list 2> /dev/null | cut -d" " -f2
            ;;
            backup-remove | backup-restore)
                authselect backup-list 2> /dev/null | cut -d" " -f1
            ;;
            enable-feature | disable-feature)
                profile="$(get_profile)";
                if [[ "$profile" != "" ]]; then
                    authselect list-features "$profile" 2> /dev/null;
                fi
            ;;
        esac
    };
    COMMANDS=(select apply-changes list list-features show requirements current check test enable-feature disable-feature create-profile backup-list backup-remove backup-restore opt-out);
    possibleopts="$(get_option_params)";
    if [[ "$possibleopts" != "" ]]; then
        if [[ "${COMP_WORDS[$COMP_CWORD]}" = "=" ]]; then
            COMPREPLY=($(compgen -W "$possibleopts"));
        else
            COMPREPLY=($(compgen -W "$possibleopts" -- "${COMP_WORDS[$COMP_CWORD]}"));
        fi;
    else
        command="$(get_command)";
        if [[ "$command" = "" ]]; then
            possibleopts="$(get_global_options) ${COMMANDS[@]}";
        else
            possibleopts="$(get_global_options) $(get_command_params) $(get_command_keywords) $(get_command_options)";
        fi;
        COMPREPLY=($(compgen -W "$possibleopts" -- "${COMP_WORDS[$COMP_CWORD]}"));
    fi
}
_available_interfaces () 
{ 
    _comp_compgen_available_interfaces "$@"
}
_bashcomp_try_faketty () 
{ 
    _comp_try_faketty "$@"
}
_cd () 
{ 
    declare -F _comp_cmd_cd &> /dev/null || __load_completion cd;
    _comp_cmd_cd "$@"
}
_cd_devices () 
{ 
    _comp_compgen -a cd_devices
}
_command () 
{ 
    _comp_command "$@"
}
_command_offset () 
{ 
    local words;
    unset -v words;
    _comp_command_offset "$@"
}
_comp__find_original_word () 
{ 
    REPLY=$1;
    [[ -v cword && -v words ]] || return 0;
    local reassembled_offset=$1 i=0 j;
    for ((j = 0; j < reassembled_offset; j++))
    do
        local word=${words[j]};
        while [[ -n $word && i -lt ${#COMP_WORDS[@]} && $word == *"${COMP_WORDS[i]}"* ]]; do
            word=${word#*"${COMP_WORDS[i++]}"};
        done;
    done;
    REPLY=$i
}
_comp__get_cword_at_cursor () 
{ 
    local cword words=();
    _comp__reassemble_words "$1" words cword;
    local i cur="" index=$COMP_POINT lead=${COMP_LINE:0:COMP_POINT};
    if [[ $index -gt 0 && ( -n $lead && -n ${lead//[[:space:]]/} ) ]]; then
        cur=$COMP_LINE;
        for ((i = 0; i <= cword; ++i))
        do
            while [[ ${#cur} -ge ${#words[i]} && ${cur:0:${#words[i]}} != "${words[i]-}" ]]; do
                cur=${cur:1};
                ((index > 0)) && ((index--));
            done;
            if ((i < cword)); then
                local old_size=${#cur};
                cur=${cur#"${words[i]}"};
                local new_size=${#cur};
                ((index -= old_size - new_size));
            fi;
        done;
        [[ -n $cur && ! -n ${cur//[[:space:]]/} ]] && cur=;
        ((index < 0)) && index=0;
    fi;
    local IFS=' 	
';
    local "$2" "$3" "$4" && _comp_upvars -a"${#words[@]}" "$2" ${words[@]+"${words[@]}"} -v "$3" "$cword" -v "$4" "${cur:0:index}"
}
_comp__included_ssh_config_files () 
{ 
    (($# < 1)) && echo "bash_completion: $FUNCNAME: missing mandatory argument CONFIG" 1>&2;
    local configfile i files f REPLY;
    configfile=$1;
    local relative_include_base;
    if [[ $configfile == /etc/ssh* ]]; then
        relative_include_base="/etc/ssh";
    else
        relative_include_base="$HOME/.ssh";
    fi;
    local depth=1;
    local -a included;
    local -a include_files;
    included=("$configfile");
    local max_depth=16;
    while ((${#included[@]} > 0 && depth++ < max_depth)); do
        _comp_split include_files "$(command sed -ne 's/^[[:blank:]]*[Ii][Nn][Cc][Ll][Uu][Dd][Ee][[:blank:]]\(.*\)$/\1/p' "${included[@]}")" || return;
        included=();
        for i in "${include_files[@]}";
        do
            if [[ $i != [~/]* ]]; then
                i="${relative_include_base}/${i}";
            fi;
            _comp_expand_tilde "$i";
            if _comp_expand_glob files '$REPLY'; then
                for f in "${files[@]}";
                do
                    if [[ -r $f && ! -d $f ]]; then
                        config+=("$f");
                        included+=("$f");
                    fi;
                done;
            fi;
        done;
    done
}
_comp__reassemble_words () 
{ 
    local exclude="" i j line ref;
    if [[ -n $1 ]]; then
        exclude="[${1//[^$COMP_WORDBREAKS]/}]";
    fi;
    printf -v "$3" %s "$COMP_CWORD";
    if [[ -n $exclude ]]; then
        line=$COMP_LINE;
        for ((i = 0, j = 0; i < ${#COMP_WORDS[@]}; i++, j++))
        do
            while [[ $i -gt 0 && ${COMP_WORDS[i]} == +($exclude) ]]; do
                [[ $line != [[:blank:]]* ]] && ((j >= 2)) && ((j--));
                ref="$2[$j]";
                printf -v "$ref" %s "${!ref-}${COMP_WORDS[i]}";
                ((i == COMP_CWORD)) && printf -v "$3" %s "$j";
                line=${line#*"${COMP_WORDS[i]}"};
                if ((i < ${#COMP_WORDS[@]} - 1)); then
                    ((i++));
                else
                    break 2;
                fi;
                [[ $line == [[:blank:]]* ]] && ((j++));
            done;
            ref="$2[$j]";
            printf -v "$ref" %s "${!ref-}${COMP_WORDS[i]}";
            line=${line#*"${COMP_WORDS[i]}"};
            ((i == COMP_CWORD)) && printf -v "$3" %s "$j";
        done;
        ((i == COMP_CWORD)) && printf -v "$3" %s "$j";
    else
        for i in "${!COMP_WORDS[@]}";
        do
            printf -v "$2[i]" %s "${COMP_WORDS[i]}";
        done;
    fi
}
_comp__split_longopt () 
{ 
    if [[ $cur == --?*=* ]]; then
        prev=${cur%%?(\\)=*};
        cur=${cur#*=};
        return 0;
    fi;
    return 1
}
_comp_abspath () 
{ 
    REPLY=$1;
    case $REPLY in 
        /*)

        ;;
        ../*)
            REPLY=$PWD/${REPLY:3}
        ;;
        *)
            REPLY=$PWD/$REPLY
        ;;
    esac;
    while [[ $REPLY == */./* ]]; do
        REPLY=${REPLY//\/.\//\/};
    done;
    REPLY=${REPLY//+(\/)/\/}
}
_comp_as_root () 
{ 
    [[ $EUID -eq 0 || -n ${_comp_root_command-} ]]
}
_comp_awk () 
{ 
    command awk "$@"
}
_comp_cmd_cd () 
{ 
    local cur prev words cword comp_args;
    _comp_initialize -- "$@" || return;
    if [[ $cur == -* ]]; then
        _comp_compgen_help -c help "$1";
        compopt +o nospace;
        return;
    fi;
    local i j k;
    compopt -o filenames;
    if [[ ! -n ${CDPATH-} || $cur == ?(.)?(.)/* ]]; then
        _comp_compgen_filedir -d;
        return;
    fi;
    local mark_dirs="" mark_symdirs="";
    _comp_readline_variable_on mark-directories && mark_dirs=set;
    _comp_readline_variable_on mark-symlinked-directories && mark_symdirs=set;
    local paths dirs;
    _comp_split -F : paths "$CDPATH";
    for i in "${paths[@]}";
    do
        k=${#COMPREPLY[@]};
        _comp_compgen -v dirs -c "$i/$cur" -- -d;
        for j in "${dirs[@]}";
        do
            if [[ ( -n $mark_symdirs && -L $j || -n $mark_dirs && ! -L $j ) && ! -d ${j#"$i/"} ]]; then
                j+="/";
            fi;
            COMPREPLY[k++]=${j#"$i/"};
        done;
    done;
    _comp_compgen -a filedir -d;
    if ((${#COMPREPLY[@]} == 1)); then
        i=${COMPREPLY[0]};
        if [[ $i == "$cur" && $i != "*/" ]]; then
            COMPREPLY[0]="${i}/";
        fi;
    fi
}
_comp_command () 
{ 
    local words;
    unset -v words;
    local offset i;
    offset=1;
    for ((i = 1; i <= COMP_CWORD; i++))
    do
        if [[ ${COMP_WORDS[i]} != -* ]]; then
            offset=$i;
            break;
        fi;
    done;
    _comp_command_offset $offset
}
_comp_command_offset () 
{ 
    local REPLY;
    _comp__find_original_word "$1";
    local word_offset=$REPLY;
    local COMP_LINE=$COMP_LINE COMP_POINT=$COMP_POINT COMP_CWORD=$COMP_CWORD;
    local -a comp_words=("${COMP_WORDS[@]}");
    local -a COMP_WORDS=("${comp_words[@]}");
    local i tail;
    for ((i = 0; i < word_offset; i++))
    do
        tail=${COMP_LINE#*"${COMP_WORDS[i]}"};
        ((COMP_POINT -= ${#COMP_LINE} - ${#tail}));
        COMP_LINE=$tail;
    done;
    COMP_WORDS=("${COMP_WORDS[@]:word_offset}");
    ((COMP_CWORD -= word_offset));
    COMPREPLY=();
    local cur;
    _comp_get_words cur;
    if ((COMP_CWORD == 0)); then
        _comp_compgen_commands;
    else
        _comp_dequote "${COMP_WORDS[0]}" || REPLY=${COMP_WORDS[0]};
        local cmd=$REPLY compcmd=$REPLY;
        local cspec=$(complete -p "$cmd" 2> /dev/null);
        if [[ ! -n $cspec && $cmd == */* ]]; then
            cspec=$(complete -p "${cmd##*/}" 2> /dev/null);
            [[ -n $cspec ]] && compcmd=${cmd##*/};
        fi;
        if [[ ! -n $cspec ]]; then
            compcmd=${cmd##*/};
            _comp_load -D -- "$compcmd";
            cspec=$(complete -p "$compcmd" 2> /dev/null);
        fi;
        local retry_count=0;
        while true; do
            local args original_cur=${comp_args[1]-$cur};
            if ((${#COMP_WORDS[@]} >= 2)); then
                args=("$cmd" "$original_cur" "${COMP_WORDS[-2]}");
            else
                args=("$cmd" "$original_cur");
            fi;
            if [[ ! -n $cspec ]]; then
                if ((${#COMPREPLY[@]} == 0)); then
                    _comp_complete_minimal "${args[@]}";
                fi;
            else
                if [[ $cspec == *\ -[CF]\ * ]]; then
                    if [[ $cspec == *' -F '* ]]; then
                        local func=${cspec#* -F };
                        func=${func%% *};
                        $func "${args[@]}";
                        if (($? == 124 && retry_count++ == 0)); then
                            COMPREPLY=();
                            cspec=$(complete -p "$compcmd" 2> /dev/null);
                            [[ -n $cspec ]] || break;
                            continue;
                        fi;
                    else
                        local completer=${cspec#* -C \'};
                        if ! _comp_dequote "'$completer"; then
                            _minimal "${args[@]}";
                            break;
                        fi;
                        completer=${REPLY[0]};
                        local -a suggestions;
                        local IFS=' 	
';
                        local reset_monitor=$(shopt -po monitor) reset_lastpipe=$(shopt -p lastpipe) reset_noglob=$(shopt -po noglob);
                        set +o monitor;
                        shopt -s lastpipe;
                        set -o noglob;
                        COMP_KEY="$COMP_KEY" COMP_LINE="$COMP_LINE" COMP_POINT="$COMP_POINT" COMP_TYPE="$COMP_TYPE" $completer "${args[@]}" | mapfile -t suggestions;
                        $reset_monitor;
                        $reset_lastpipe;
                        $reset_noglob;
                        _comp_unlocal IFS;
                        local suggestion;
                        local i=0;
                        COMPREPLY=();
                        for suggestion in "${suggestions[@]}";
                        do
                            COMPREPLY[i]+=${COMPREPLY[i]+'
'}$suggestion;
                            if [[ $suggestion != *\\ ]]; then
                                ((i++));
                            fi;
                        done;
                    fi;
                    local opt;
                    while [[ $cspec == *" -o "* ]]; do
                        cspec=${cspec#*-o };
                        opt=${cspec%% *};
                        compopt -o "$opt";
                        cspec=${cspec#"$opt"};
                    done;
                else
                    cspec=${cspec#complete};
                    cspec=${cspec%%@("$compcmd"|"'${compcmd//\'/\'\\\'\'}'")};
                    eval "_comp_compgen -- $cspec";
                fi;
            fi;
            break;
        done;
    fi
}
_comp_compgen () 
{ 
    local _append=;
    local _var=;
    local _cur=${_comp_compgen__cur-${cur-}};
    local _dir="";
    local _ifs=' 	
' _has_ifs="";
    local _icmd="" _xcmd="";
    local -a _upvars=();
    local _old_nocasematch="";
    if shopt -q nocasematch; then
        _old_nocasematch=set;
        shopt -u nocasematch;
    fi;
    local OPTIND=1 OPTARG="" OPTERR=0 _opt;
    while getopts ':av:U:Rc:C:lF:i:x:' _opt "$@"; do
        case $_opt in 
            a)
                _append=set
            ;;
            v)
                if [[ $OPTARG == @(*[^_a-zA-Z0-9]*|[0-9]*|''|_*|IFS|OPTIND|OPTARG|OPTERR|cur) ]]; then
                    printf 'bash_completion: %s: -v: invalid array name `%s'\''\n' "$FUNCNAME" "$OPTARG" 1>&2;
                    return 2;
                fi;
                _var=$OPTARG
            ;;
            U)
                if [[ $OPTARG == @(*[^_a-zA-Z0-9]*|[0-9]*|'') ]]; then
                    printf 'bash_completion: %s: -U: invalid variable name `%s'\''\n' "$FUNCNAME" "$OPTARG" 1>&2;
                    return 2;
                else
                    if [[ $OPTARG == @(_*|IFS|OPTIND|OPTARG|OPTERR|cur) ]]; then
                        printf 'bash_completion: %s: -U: unnecessary to mark `%s'\'' as upvar\n' "$FUNCNAME" "$OPTARG" 1>&2;
                        return 2;
                    fi;
                fi;
                _upvars+=("$OPTARG")
            ;;
            c)
                _cur=$OPTARG
            ;;
            R)
                _cur=""
            ;;
            C)
                if [[ ! -n $OPTARG ]]; then
                    printf 'bash_completion: %s: -C: invalid directory name `%s'\''\n' "$FUNCNAME" "$OPTARG" 1>&2;
                    return 2;
                fi;
                _dir=$OPTARG
            ;;
            l)
                _has_ifs=set _ifs='
'
            ;;
            F)
                _has_ifs=set _ifs=$OPTARG
            ;;
            [ix])
                if [[ ! -n $OPTARG ]]; then
                    printf 'bash_completion: %s: -%s: invalid command name `%s'\''\n' "$FUNCNAME" "$_opt" "$OPTARG" 1>&2;
                    return 2;
                else
                    if [[ -n $_icmd ]]; then
                        printf 'bash_completion: %s: -%s: `-i %s'\'' is already specified\n' "$FUNCNAME" "$_opt" "$_icmd" 1>&2;
                        return 2;
                    else
                        if [[ -n $_xcmd ]]; then
                            printf 'bash_completion: %s: -%s: `-x %s'\'' is already specified\n' "$FUNCNAME" "$_opt" "$_xcmd" 1>&2;
                            return 2;
                        fi;
                    fi;
                fi
            ;;&
            i)
                _icmd=$OPTARG
            ;;
            x)
                _xcmd=$OPTARG
            ;;
            *)
                printf 'bash_completion: %s: usage error\n' "$FUNCNAME" 1>&2;
                return 2
            ;;
        esac;
    done;
    [[ -n $_old_nocasematch ]] && shopt -s nocasematch;
    shift "$((OPTIND - 1))";
    if (($# == 0)); then
        printf 'bash_completion: %s: unexpected number of arguments\n' "$FUNCNAME" 1>&2;
        printf 'usage: %s [-alR|-F SEP|-v ARR|-c CUR] -- ARGS...' "$FUNCNAME" 1>&2;
        return 2;
    fi;
    if [[ ! -n $_var ]]; then
        _var=${_comp_compgen__var-COMPREPLY};
        [[ -n $_append ]] || _append=${_comp_compgen__append-};
    fi;
    if [[ $1 != -* ]]; then
        if [[ -n $_has_ifs ]]; then
            printf 'bash_completion: %s: `-l'\'' and `-F sep'\'' are not supported for generators\n' "$FUNCNAME" 1>&2;
            return 2;
        fi;
        local -a _generator;
        if [[ -n $_icmd ]]; then
            _generator=("_comp_cmd_${_icmd//[^a-zA-Z0-9_]/_}__compgen_$1");
        else
            if [[ -n $_xcmd ]]; then
                _generator=(_comp_xfunc "$_xcmd" "compgen_$1");
            else
                _generator=("_comp_compgen_$1");
            fi;
        fi;
        if ! declare -F "${_generator[0]}" &> /dev/null; then
            printf 'bash_completion: %s: unrecognized generator `%s'\'' (function %s not found)\n' "$FUNCNAME" "$1" "${_generator[0]}" 1>&2;
            return 2;
        fi;
        ((${#_upvars[@]})) && _comp_unlocal "${_upvars[@]}";
        if [[ -n $_dir ]]; then
            local _original_pwd=$PWD;
            local PWD=${PWD-} OLDPWD=${OLDPWD-};
            command cd -- "$_dir" &> /dev/null || { 
                _comp_compgen__error_fallback;
                return
            };
        fi;
        local _comp_compgen__append=$_append;
        local _comp_compgen__var=$_var;
        local _comp_compgen__cur=$_cur cur=$_cur;
        "${_generator[@]}" "${@:2}";
        local _status=$?;
        [[ -n $_dir ]] && command cd -- "$_original_pwd";
        return "$_status";
    fi;
    if [[ -n $_icmd || -n $_xcmd ]]; then
        printf 'bash_completion: %s: generator name is unspecified for `%s'\''\n' "$FUNCNAME" "${_icmd:+-i $_icmd}${_xcmd:+x $_xcmd}" 1>&2;
        return 2;
    fi;
    local IFS=' 	
';
    if [[ $* == *\$[0-9]* || $* == *\$\{[0-9]* ]]; then
        printf 'bash_completion: %s: positional parameter $1, $2, ... do not work inside this function\n' "$FUNCNAME" 1>&2;
        return 2;
    fi;
    local _result;
    _result=$(if [[ -n $_dir ]]; then
    command cd -- "$_dir" &> /dev/null || return;
fi
IFS=$_ifs compgen "$@" ${_cur:+-- "$_cur"}) || { 
        _comp_compgen__error_fallback;
        return
    };
    ((${#_upvars[@]})) && _comp_unlocal "${_upvars[@]}";
    _comp_split -l ${_append:+-a} "$_var" "$_result"
}
_comp_compgen__error_fallback () 
{ 
    local _status=$?;
    if [[ -n $_append ]]; then
        eval -- "$_var+=()";
    else
        eval -- "$_var=()";
    fi;
    return "$_status"
}
_comp_compgen_allowed_groups () 
{ 
    if _comp_as_root; then
        _comp_compgen -- -g;
    else
        _comp_compgen_split -- "$(id -Gn 2> /dev/null || groups 2> /dev/null)";
    fi
}
_comp_compgen_allowed_users () 
{ 
    if _comp_as_root; then
        _comp_compgen -- -u;
    else
        _comp_compgen_split -- "$(id -un 2> /dev/null || whoami 2> /dev/null)";
    fi
}
_comp_compgen_available_interfaces () 
{ 
    local PATH=$PATH:/sbin;
    local generated;
    _comp_compgen -v generated split -- "$({ if [[ ${1-} == -w ]]; then
    iwconfig;
else
    if [[ ${1-} == -a ]]; then
        ifconfig || ip -c=never link show up || ip link show up;
    else
        ifconfig -a || ip -c=never link show || ip link show;
    fi;
fi; } 2> /dev/null | _comp_awk '/^[^ \t]/ { if ($1 ~ /^[0-9]+:/) { print $2 } else { print $1 } }')" && _comp_compgen -U generated set "${generated[@]%%[[:punct:]]*}"
}
_comp_compgen_cd_devices () 
{ 
    _comp_compgen -c "${cur:-/dev/}" -- -f -d -X "!*/?([amrs])cd!(c-*)"
}
_comp_compgen_commands () 
{ 
    [[ ! -n ${cur-} ]] && shopt -q no_empty_cmd_completion && return 1;
    _comp_compgen -- -c -o plusdirs && compopt -o filenames
}
_comp_compgen_configured_interfaces () 
{ 
    local -a files;
    if [[ -f /etc/debian_version ]]; then
        _comp_expand_glob files '/etc/network/interfaces /etc/network/interfaces.d/*' || return 0;
        _comp_compgen -U files split -- "$(command sed -ne 's|^iface \([^ ]\{1,\}\).*$|\1|p' "${files[@]}" 2> /dev/null)";
    else
        if [[ -f /etc/SuSE-release ]]; then
            _comp_expand_glob files '/etc/sysconfig/network/ifcfg-*' || return 0;
            _comp_compgen -U files split -- "$(printf '%s\n' "${files[@]}" | command sed -ne 's|.*ifcfg-\([^*].*\)$|\1|p')";
        else
            if [[ -f /etc/pld-release ]]; then
                _comp_compgen -U files split -- "$(command ls -B /etc/sysconfig/interfaces | command sed -ne 's|.*ifcfg-\([^*].*\)$|\1|p')";
            else
                _comp_expand_glob files '/etc/sysconfig/network-scripts/ifcfg-*' || return 0;
                _comp_compgen -U files split -- "$(printf '%s\n' "${files[@]}" | command sed -ne 's|.*ifcfg-\([^*].*\)$|\1|p')";
            fi;
        fi;
    fi
}
_comp_compgen_dvd_devices () 
{ 
    _comp_compgen -c "${cur:-/dev/}" -- -f -d -X "!*/?(r)dvd*"
}
_comp_compgen_filedir () 
{ 
    _comp_compgen_tilde && return;
    local -a toks;
    local _arg=${1-};
    if [[ $_arg == -d ]]; then
        _comp_compgen -v toks -- -d;
    else
        local REPLY;
        _comp_quote_compgen "${cur-}";
        local _quoted=$REPLY;
        _comp_unlocal REPLY;
        [[ $_quoted == "''" ]] && _quoted="";
        local _xspec=${_arg:+"!*.@($_arg|${_arg^^})"} _plusdirs=();
        local _opts=(-f -X "$_xspec");
        [[ -n $_xspec ]] && _plusdirs=(-o plusdirs);
        [[ -n ${BASH_COMPLETION_FILEDIR_FALLBACK-} || ! -n ${_plusdirs-} ]] || _opts+=("${_plusdirs[@]}");
        _comp_compgen -v toks -c "$_quoted" -- "${_opts[@]}";
        [[ -n ${BASH_COMPLETION_FILEDIR_FALLBACK-} && -n $_arg && ${#toks[@]} -lt 1 ]] && _comp_compgen -av toks -c "$_quoted" -- -f ${_plusdirs+"${_plusdirs[@]}"};
    fi;
    if ((${#toks[@]} != 0)); then
        compopt -o filenames 2> /dev/null;
    fi;
    local IFS=' 	
';
    _comp_compgen -U toks set ${toks[@]+"${toks[@]}"}
}
_comp_compgen_filedir_xspec () 
{ 
    _comp_compgen_tilde && return;
    local REPLY;
    _comp_quote_compgen "$cur";
    local quoted=$REPLY;
    local xspec=${_comp_xspecs[${1##*/}]-${_xspecs[${1##*/}]-}};
    local -a toks;
    _comp_compgen -v toks -c "$quoted" -- -d;
    eval xspec="${xspec}";
    local matchop=!;
    if [[ $xspec == !* ]]; then
        xspec=${xspec#!};
        matchop=@;
    fi;
    xspec="$matchop($xspec|${xspec^^})";
    _comp_compgen -av toks -c "$quoted" -- -f -X "@(|!($xspec))";
    [[ -n ${BASH_COMPLETION_FILEDIR_FALLBACK-} && ${#toks[@]} -lt 1 ]] && _comp_compgen -av toks -c "$quoted" -- -f;
    ((${#toks[@]})) || return 1;
    compopt -o filenames;
    _comp_compgen -RU toks -- -W '"${toks[@]}"'
}
_comp_compgen_fstypes () 
{ 
    local _fss;
    if [[ -e /proc/filesystems ]]; then
        _fss="$(cut -d'	' -f2 /proc/filesystems)
             $(_comp_awk '! /\*/ { print $NF }' /etc/filesystems 2> /dev/null)";
    else
        _fss="$(_comp_awk '/^[ \t]*[^#]/ { print $3 }' /etc/fstab 2> /dev/null)
             $(_comp_awk '/^[ \t]*[^#]/ { print $3 }' /etc/mnttab 2> /dev/null)
             $(_comp_awk '/^[ \t]*[^#]/ { print $4 }' /etc/vfstab 2> /dev/null)
             $(_comp_awk '{ print $1 }' /etc/dfs/fstypes 2> /dev/null)
             $(lsvfs 2> /dev/null | _comp_awk '$1 !~ /^(Filesystem|[^a-zA-Z])/ { print $1 }')
             $([[ -d /etc/fs ]] && command ls /etc/fs)";
    fi;
    [[ -n $_fss ]] && _comp_compgen_split -- "$_fss"
}
_comp_compgen_gids () 
{ 
    if type getent &> /dev/null; then
        _comp_compgen_split -- "$(getent group | cut -d: -f3)";
    else
        if type perl &> /dev/null; then
            _comp_compgen_split -- "$(perl -e 'while (($gid) = (getgrent)[2]) { print $gid . "\n" }')";
        else
            _comp_compgen_split -- "$(cut -d: -f3 /etc/group)";
        fi;
    fi
}
_comp_compgen_help () 
{ 
    (($#)) || set -- -- --help;
    local -a _lines;
    _comp_compgen_help__get_help_lines "$@" || return "$?";
    local -a options=();
    local _line;
    for _line in "${_lines[@]}";
    do
        [[ $_line == *([[:blank:]])-* ]] || continue;
        while [[ $_line =~ ((^|[^-])-[A-Za-z0-9?][[:space:]]+)\[?[A-Z0-9]+([,_-]+[A-Z0-9]+)?(\.\.+)?\]? ]]; do
            _line=${_line/"${BASH_REMATCH[0]}"/"${BASH_REMATCH[1]}"};
        done;
        _comp_compgen_help__parse "${_line// or /, }";
    done;
    ((${#options[@]})) || return 1;
    _comp_compgen -U options -- -W '"${options[@]}"';
    return 0
}
_comp_compgen_help__get_help_lines () 
{ 
    local -a help_cmd;
    case ${1-} in 
        -)
            if (($# > 1)); then
                printf 'bash_completion: %s -: extra arguments for -\n' "${FUNCNAME[1]}" 1>&2;
                printf 'usage: %s -\n' "${FUNCNAME[1]}" 1>&2;
                printf 'usage: %s -c cmd args...\n' "${FUNCNAME[1]}" 1>&2;
                printf 'usage: %s [-- args...]\n' "${FUNCNAME[1]}" 1>&2;
                return 2;
            fi;
            help_cmd=(exec cat)
        ;;
        -c)
            if (($# < 2)); then
                printf 'bash_completion: %s -c: no command is specified\n' "${FUNCNAME[1]}" 1>&2;
                printf 'usage: %s -\n' "${FUNCNAME[1]}" 1>&2;
                printf 'usage: %s -c cmd args...\n' "${FUNCNAME[1]}" 1>&2;
                printf 'usage: %s [-- args...]\n' "${FUNCNAME[1]}" 1>&2;
                return 2;
            fi;
            help_cmd=("${@:2}")
        ;;
        --)
            shift 1
        ;&
        *)
            local REPLY;
            _comp_dequote "${comp_args[0]-}" || REPLY=${comp_args[0]-};
            help_cmd=("${REPLY:-false}" "$@")
        ;;
    esac;
    local REPLY;
    _comp_split -l REPLY "$(LC_ALL=C "${help_cmd[@]}" 2>&1)" && _lines=("${REPLY[@]}")
}
_comp_compgen_help__parse () 
{ 
    local option option2 i;
    option=;
    local -a array;
    if _comp_split -F ' 	
,/|' array "$1"; then
        for i in "${array[@]}";
        do
            case "$i" in 
                ---*)
                    break
                ;;
                --?*)
                    option=$i;
                    break
                ;;
                -?*)
                    [[ -n $option ]] || option=$i
                ;;
                *)
                    break
                ;;
            esac;
        done;
    fi;
    [[ -n $option ]] || return 1;
    if [[ $option =~ (\[((no|dont)-?)\]). ]]; then
        option2=${option/"${BASH_REMATCH[1]}"/};
        option2=${option2%%[<{().[]*};
        options+=("${option2/=*/=}");
        option=${option/"${BASH_REMATCH[1]}"/"${BASH_REMATCH[2]}"};
    fi;
    [[ $option =~ ^([^=<{().[]|\.[A-Za-z0-9])+=? ]] && options+=("$BASH_REMATCH")
}
_comp_compgen_inserted_kernel_modules () 
{ 
    _comp_compgen -c "${1:-$cur}" split -- "$(PATH="$PATH:/sbin" lsmod | _comp_awk '{if (NR != 1) print $1}')"
}
_comp_compgen_ip_addresses () 
{ 
    local _n;
    case ${1-} in 
        -a)
            _n='6\{0,1\}'
        ;;
        -6)
            _n='6'
        ;;
        *)
            _n=
        ;;
    esac;
    local PATH=$PATH:/sbin;
    local addrs;
    _comp_compgen -v addrs split -- "$({ LC_ALL=C ifconfig -a || ip -c=never addr show || ip addr show; } 2> /dev/null | command sed -e 's/[[:space:]]addr:/ /' -ne "s|.*inet${_n}[[:space:]]\{1,\}\([^[:space:]/]*\).*|\1|p")" || return;
    if [[ ! -n $_n ]]; then
        _comp_compgen -U addrs set "${addrs[@]}";
    else
        _comp_compgen -U addrs ltrim_colon "${addrs[@]}";
    fi
}
_comp_compgen_kernel_modules () 
{ 
    local _modpath=/lib/modules/$1;
    _comp_compgen_split -- "$(command ls -RL "$_modpath" 2> /dev/null | command sed -ne 's/^\(.*\)\.k\{0,1\}o\(\.[gx]z\)\{0,1\}$/\1/p' -e 's/^\(.*\)\.ko\.zst$/\1/p')"
}
_comp_compgen_kernel_versions () 
{ 
    _comp_compgen_split -- "$(command ls /lib/modules)"
}
_comp_compgen_known_hosts () 
{ 
    local known_hosts;
    _comp_compgen_known_hosts__impl "$@" || return "$?";
    _comp_compgen -U known_hosts set "${known_hosts[@]}"
}
_comp_compgen_known_hosts__impl () 
{ 
    known_hosts=();
    local configfile="" flag prefix="";
    local cur suffix="" aliases="" i host ipv4="" ipv6="";
    local -a kh tmpkh=() khd=() config=();
    local OPTIND=1;
    while getopts "ac46F:p:" flag "$@"; do
        case $flag in 
            a)
                aliases=set
            ;;
            c)
                suffix=':'
            ;;
            F)
                if [[ ! -n $OPTARG ]]; then
                    echo "bash_completion: $FUNCNAME: -F: an empty filename is specified" 1>&2;
                    return 2;
                fi;
                configfile=$OPTARG
            ;;
            p)
                prefix=$OPTARG
            ;;
            4)
                ipv4=set
            ;;
            6)
                ipv6=set
            ;;
            *)
                echo "bash_completion: $FUNCNAME: usage error" 1>&2;
                return 2
            ;;
        esac;
    done;
    if (($# < OPTIND)); then
        echo "bash_completion: $FUNCNAME: missing mandatory argument CWORD" 1>&2;
        return 2;
    fi;
    cur=${!OPTIND};
    ((OPTIND += 1));
    if (($# >= OPTIND)); then
        echo "bash_completion: $FUNCNAME($*): unprocessed arguments:" "$(while (($# >= OPTIND)); do
    printf '%s ' ${!OPTIND}
shift;
done)" 1>&2;
        return 2;
    fi;
    [[ $cur == *@* ]] && prefix=$prefix${cur%@*}@ && cur=${cur#*@};
    kh=();
    if [[ -n $configfile ]]; then
        [[ -r $configfile && ! -d $configfile ]] && config+=("$configfile");
    else
        for i in /etc/ssh/ssh_config ~/.ssh/config ~/.ssh2/config;
        do
            [[ -r $i && ! -d $i ]] && config+=("$i");
        done;
    fi;
    if ((${#config[@]} > 0)); then
        for i in "${config[@]}";
        do
            _comp__included_ssh_config_files "$i";
        done;
    fi;
    if ((${#config[@]} > 0)); then
        if _comp_split -l tmpkh "$(_comp_awk 'sub("^[ \t]*([Gg][Ll][Oo][Bb][Aa][Ll]|[Uu][Ss][Ee][Rr])[Kk][Nn][Oo][Ww][Nn][Hh][Oo][Ss][Tt][Ss][Ff][Ii][Ll][Ee][ \t=]+", "") { print $0 }' "${config[@]}" | sort -u)"; then
            local tmpkh2 j REPLY;
            for i in "${tmpkh[@]}";
            do
                while [[ $i =~ ^([^\"]*)\"([^\"]*)\"(.*)$ ]]; do
                    i=${BASH_REMATCH[1]}${BASH_REMATCH[3]};
                    _comp_expand_tilde "${BASH_REMATCH[2]}";
                    [[ -r $REPLY ]] && kh+=("$REPLY");
                done;
                _comp_split tmpkh2 "$i" || continue;
                for j in "${tmpkh2[@]}";
                do
                    _comp_expand_tilde "$j";
                    [[ -r $REPLY ]] && kh+=("$REPLY");
                done;
            done;
        fi;
    fi;
    if [[ ! -n $configfile ]]; then
        for i in /etc/ssh/ssh_known_hosts /etc/ssh/ssh_known_hosts2 /etc/known_hosts /etc/known_hosts2 ~/.ssh/known_hosts ~/.ssh/known_hosts2;
        do
            [[ -r $i && ! -d $i ]] && kh+=("$i");
        done;
        for i in /etc/ssh2/knownhosts ~/.ssh2/hostkeys;
        do
            [[ -d $i ]] || continue;
            _comp_expand_glob tmpkh '"$i"/*.pub' && khd+=("${tmpkh[@]}");
        done;
    fi;
    if ((${#kh[@]} + ${#khd[@]} > 0)); then
        if ((${#kh[@]} > 0)); then
            for i in "${kh[@]}";
            do
                while read -ra tmpkh; do
                    ((${#tmpkh[@]} == 0)) && continue;
                    [[ ${tmpkh[0]} == [\|\#]* ]] && continue;
                    local host_list=${tmpkh[0]};
                    [[ ${tmpkh[0]} == @* ]] && host_list=${tmpkh[1]-};
                    local -a hosts;
                    if _comp_split -F , hosts "$host_list"; then
                        for host in "${hosts[@]}";
                        do
                            [[ $host == *[*?]* ]] && continue;
                            host=${host#[};
                            host=${host%]?(:+([0-9]))};
                            [[ -n $host ]] && known_hosts+=("$host");
                        done;
                    fi;
                done < "$i";
            done;
        fi;
        if ((${#khd[@]} > 0)); then
            for i in "${khd[@]}";
            do
                if [[ $i == *key_22_*.pub && -r $i ]]; then
                    host=${i/#*key_22_/};
                    host=${host/%.pub/};
                    [[ -n $host ]] && known_hosts+=("$host");
                fi;
            done;
        fi;
        ((${#known_hosts[@]})) && _comp_compgen -v known_hosts -- -W '"${known_hosts[@]}"' -P "$prefix" -S "$suffix";
    fi;
    if [[ ${#config[@]} -gt 0 && -n $aliases ]]; then
        local -a hosts;
        if _comp_split hosts "$(command sed -ne 's/^[[:blank:]]*[Hh][Oo][Ss][Tt][[:blank:]=]\{1,\}\(.*\)$/\1/p' "${config[@]}")"; then
            _comp_compgen -av known_hosts -- -P "$prefix" -S "$suffix" -W '"${hosts[@]%%[*?%]*}"' -X '@(\!*|)';
        fi;
    fi;
    if [[ -n ${BASH_COMPLETION_KNOWN_HOSTS_WITH_AVAHI-} ]] && type avahi-browse &> /dev/null; then
        local generated=$(avahi-browse -cprak 2> /dev/null | _comp_awk -F ';' '/^=/ && $5 ~ /^_(ssh|workstation)\._tcp$/ { print $7 }' | sort -u);
        _comp_compgen -av known_hosts -- -P "$prefix" -S "$suffix" -W '$generated';
    fi;
    if type ruptime &> /dev/null; then
        local generated=$(ruptime 2> /dev/null | _comp_awk '!/^ruptime:/ { print $1 }');
        _comp_compgen -av known_hosts -- -W '$generated';
    fi;
    if [[ -n ${BASH_COMPLETION_KNOWN_HOSTS_WITH_HOSTFILE-set} ]]; then
        _comp_compgen -av known_hosts -- -A hostname -P "$prefix" -S "$suffix";
    fi;
    ((${#known_hosts[@]})) || return 1;
    if [[ -n $ipv4 ]]; then
        known_hosts=("${known_hosts[@]/*:*$suffix/}");
    fi;
    if [[ -n $ipv6 ]]; then
        known_hosts=("${known_hosts[@]/+([0-9]).+([0-9]).+([0-9]).+([0-9])$suffix/}");
    fi;
    if [[ -n $ipv4 || -n $ipv6 ]]; then
        for i in "${!known_hosts[@]}";
        do
            [[ -n ${known_hosts[i]} ]] || unset -v 'known_hosts[i]';
        done;
    fi;
    ((${#known_hosts[@]})) || return 1;
    _comp_compgen -v known_hosts -c "$prefix$cur" ltrim_colon "${known_hosts[@]}"
}
_comp_compgen_ltrim_colon () 
{ 
    (($#)) || return 0;
    local -a _tmp;
    _tmp=("$@");
    if [[ $cur == *:* && $COMP_WORDBREAKS == *:* ]]; then
        local _colon_word=${cur%"${cur##*:}"};
        _tmp=("${_tmp[@]#"$_colon_word"}");
    fi;
    _comp_compgen_set "${_tmp[@]}"
}
_comp_compgen_mac_addresses () 
{ 
    local _re='\([A-Fa-f0-9]\{2\}:\)\{5\}[A-Fa-f0-9]\{2\}';
    local PATH="$PATH:/sbin:/usr/sbin";
    local -a addresses;
    _comp_compgen -v addresses split -- "$({ LC_ALL=C ifconfig -a || ip -c=never link show || ip link show; } 2> /dev/null | command sed -ne "s/.*[[:space:]]HWaddr[[:space:]]\{1,\}\($_re\)[[:space:]].*/\1/p" -ne "s/.*[[:space:]]HWaddr[[:space:]]\{1,\}\($_re\)[[:space:]]*$/\1/p" -ne "s|.*[[:space:]]\(link/\)\{0,1\}ether[[:space:]]\{1,\}\($_re\)[[:space:]].*|\2|p" -ne "s|.*[[:space:]]\(link/\)\{0,1\}ether[[:space:]]\{1,\}\($_re\)[[:space:]]*$|\2|p")";
    _comp_compgen -av addresses split -- "$({ arp -an || ip -c=never neigh show || ip neigh show; } 2> /dev/null | command sed -ne "s/.*[[:space:]]\($_re\)[[:space:]].*/\1/p" -ne "s/.*[[:space:]]\($_re\)[[:space:]]*$/\1/p")";
    _comp_compgen -av addresses split -- "$(command sed -ne "s/^[[:space:]]*\($_re\)[[:space:]].*/\1/p" /etc/ethers 2> /dev/null)";
    _comp_compgen -U addresses ltrim_colon "${addresses[@]}"
}
_comp_compgen_pci_ids () 
{ 
    _comp_compgen_split -- "$(PATH="$PATH:/sbin" lspci -n | _comp_awk '{print $3}')"
}
_comp_compgen_pgids () 
{ 
    _comp_compgen_split -- "$(command ps ax -o pgid=)"
}
_comp_compgen_pids () 
{ 
    _comp_compgen_split -- "$(command ps ax -o pid=)"
}
_comp_compgen_pnames () 
{ 
    local -a procs=();
    if [[ ${1-} == -s ]]; then
        _comp_split procs "$(command ps ax -o comm | command sed -e 1d)";
    else
        local -a psout;
        _comp_split -l psout "$({ command ps ax -o command= || command ps ax -o comm=; } 2> /dev/null)";
        local line i=-1;
        for line in "${psout[@]}";
        do
            if ((i == -1)); then
                if [[ $line =~ ^(.*[[:space:]])COMMAND([[:space:]]|$) ]]; then
                    i=${#BASH_REMATCH[1]};
                else
                    break;
                fi;
            else
                line=${line:i};
                line=${line%% *};
                [[ -n $line ]] && procs+=("$line");
            fi;
        done;
        if ((i == -1)); then
            for line in "${psout[@]}";
            do
                if [[ $line =~ ^[[(](.+)[])]$ ]]; then
                    procs+=("${BASH_REMATCH[1]}");
                else
                    line=${line%% *};
                    line=${line##@(*/|-)};
                    [[ -n $line ]] && procs+=("$line");
                fi;
            done;
        fi;
    fi;
    ((${#procs[@]})) && _comp_compgen -U procs -- -X "<defunct>" -W '"${procs[@]}"'
}
_comp_compgen_selinux_users () 
{ 
    _comp_compgen_split -- "$(semanage user -nl 2> /dev/null | _comp_awk '{ print $1 }')"
}
_comp_compgen_services () 
{ 
    local sysvdirs;
    _comp_sysvdirs || return 1;
    local services;
    _comp_expand_glob services '${sysvdirs[0]}/!($_comp_backup_glob|functions|README)';
    local _generated=$({ systemctl list-units --full --all || systemctl list-unit-files; } 2> /dev/null | _comp_awk '$1 ~ /\.service$/ { sub("\\.service$", "", $1); print $1 }');
    _comp_split -la services "$_generated";
    if [[ -x /sbin/upstart-udev-bridge ]]; then
        _comp_split -la services "$(initctl list 2> /dev/null | cut -d' ' -f1)";
    fi;
    ((${#services[@]})) || return 1;
    _comp_compgen -U services -U sysvdirs -- -W '"${services[@]#${sysvdirs[0]}/}"'
}
_comp_compgen_set () 
{ 
    local _append=${_comp_compgen__append-};
    local _var=${_comp_compgen__var-COMPREPLY};
    eval -- "$_var${_append:++}=(\"\$@\")";
    (($#))
}
_comp_compgen_shells () 
{ 
    local -a shells=();
    local _shell _rest;
    while read -r _shell _rest; do
        [[ $_shell == /* ]] && shells+=("$_shell");
    done 2> /dev/null < "${1-}"/etc/shells;
    _comp_compgen -U shells -- -W '"${shells[@]}"'
}
_comp_compgen_signals () 
{ 
    local -a sigs;
    _comp_compgen -v sigs -c "SIG${cur#"${1-}"}" -- -A signal && _comp_compgen -RU sigs -- -P "${1-}" -W '"${sigs[@]#SIG}"'
}
_comp_compgen_split () 
{ 
    local _ifs=' 	
';
    local -a _compgen_options=();
    local OPTIND=1 OPTARG="" OPTERR=0 _opt;
    while getopts ':lF:X:S:P:o:' _opt "$@"; do
        case $_opt in 
            l)
                _ifs='
'
            ;;
            F)
                _ifs=$OPTARG
            ;;
            [XSPo])
                _compgen_options+=("-$_opt" "$OPTARG")
            ;;
            *)
                printf 'bash_completion: usage: %s [-l|-F sep] [--] str\n' "$FUNCNAME" 1>&2;
                return 2
            ;;
        esac;
    done;
    shift "$((OPTIND - 1))";
    if (($# != 1)); then
        printf 'bash_completion: %s: unexpected number of arguments.\n' "$FUNCNAME" 1>&2;
        printf 'usage: %s [-l|-F sep] [--] str' "$FUNCNAME" 1>&2;
        return 2;
    fi;
    local input=$1 IFS=' 	
';
    _comp_compgen -F "$_ifs" -U input -- ${_compgen_options[@]+"${_compgen_options[@]}"} -W '$input'
}
_comp_compgen_terms () 
{ 
    _comp_compgen_split -- "$({ command sed -ne 's/^\([^[:space:]#|]\{2,\}\)|.*/\1/p' /etc/termcap
{ toe -a || toe; } | _comp_awk '{ print $1 }'
_comp_expand_glob dirs '/{etc,lib,usr/lib,usr/share}/terminfo/?' && find "${dirs[@]}" -type f -maxdepth 1 | _comp_awk -F / '{ print $NF }'; } 2> /dev/null)"
}
_comp_compgen_tilde () 
{ 
    if [[ ${cur-} == \~* && $cur != */* ]]; then
        if _comp_compgen -c "${cur#\~}" -- -P '~' -u; then
            compopt -o filenames 2> /dev/null;
            return 0;
        fi;
    fi;
    return 1
}
_comp_compgen_uids () 
{ 
    if type getent &> /dev/null; then
        _comp_compgen_split -- "$(getent passwd | cut -d: -f3)";
    else
        if type perl &> /dev/null; then
            _comp_compgen_split -- "$(perl -e 'while (($uid) = (getpwent)[2]) { print $uid . "\n" }')";
        else
            _comp_compgen_split -- "$(cut -d: -f3 /etc/passwd)";
        fi;
    fi
}
_comp_compgen_usage () 
{ 
    (($#)) || set -- -- --usage;
    local -a _lines;
    _comp_compgen_help__get_help_lines "$@" || return "$?";
    local -a options=();
    local _line _match _option _i _char;
    for _line in "${_lines[@]}";
    do
        while [[ $_line =~ \[[[:space:]]*(-[^]]+)[[:space:]]*\] ]]; do
            _match=${BASH_REMATCH[0]};
            _option=${BASH_REMATCH[1]};
            case $_option in 
                -?(\[)+([a-zA-Z0-9?]))
                    for ((_i = 1; _i < ${#_option}; _i++))
                    do
                        _char=${_option:_i:1};
                        [[ $_char != '[' ]] && options+=("-$_char");
                    done
                ;;
                *)
                    _comp_compgen_help__parse "$_option"
                ;;
            esac;
            _line=${_line#*"$_match"};
        done;
    done;
    ((${#options[@]})) || return 1;
    _comp_compgen -U options -- -W '"${options[@]}"';
    return 0
}
_comp_compgen_usb_ids () 
{ 
    _comp_compgen_split -- "$(PATH="$PATH:/sbin" lsusb | _comp_awk '{print $6}')"
}
_comp_compgen_usergroups () 
{ 
    if [[ $cur == *\\\\* || $cur == *:*:* ]]; then
        return;
    else
        if [[ $cur == *\\:* ]]; then
            local tmp;
            if [[ ${1-} == -u ]]; then
                _comp_compgen -v tmp -c "${cur#*:}" allowed_groups;
            else
                _comp_compgen -v tmp -c "${cur#*:}" -- -g;
            fi;
            if ((${#tmp[@]})); then
                local _prefix=${cur%%*([^:])};
                _prefix=${_prefix//\\/};
                _comp_compgen -Rv tmp -- -P "$_prefix" -W '"${tmp[@]}"';
                _comp_compgen -U tmp set "${tmp[@]}";
            fi;
        else
            if [[ $cur == *:* ]]; then
                if [[ ${1-} == -u ]]; then
                    _comp_compgen -c "${cur#*:}" allowed_groups;
                else
                    _comp_compgen -c "${cur#*:}" -- -g;
                fi;
            else
                if [[ ${1-} == -u ]]; then
                    _comp_compgen_allowed_users;
                else
                    _comp_compgen -- -u;
                fi;
            fi;
        fi;
    fi
}
_comp_compgen_variables () 
{ 
    if [[ $cur =~ ^(\$(\{[!#]?)?)([A-Za-z0-9_]*)$ ]]; then
        if [[ $cur == '${'* ]]; then
            local arrs vars;
            _comp_compgen -v vars -c "${BASH_REMATCH[3]}" -- -A variable -P "${BASH_REMATCH[1]}" -S '}';
            _comp_compgen -v arrs -c "${BASH_REMATCH[3]}" -- -A arrayvar -P "${BASH_REMATCH[1]}" -S '[';
            if ((${#vars[@]} == 1 && ${#arrs[@]} != 0)); then
                compopt -o nospace;
                _comp_compgen -U vars -U arrs -R -- -W '"${arrs[@]}"';
            else
                _comp_compgen -U vars -U arrs -R -- -W '"${vars[@]}"';
            fi;
        else
            _comp_compgen -ac "${BASH_REMATCH[3]}" -- -A variable -P '$';
        fi;
        return 0;
    else
        if [[ $cur =~ ^(\$\{[#!]?)([A-Za-z0-9_]*)\[([^]]*)$ ]]; then
            local vars;
            _comp_compgen -v vars -c "${BASH_REMATCH[3]}" -- -W '"${!'"${BASH_REMATCH[2]}"'[@]}"' -P "${BASH_REMATCH[1]}${BASH_REMATCH[2]}[" -S ']}';
            if [[ ${BASH_REMATCH[3]} == [@*] ]]; then
                vars+=("${BASH_REMATCH[1]}${BASH_REMATCH[2]}[${BASH_REMATCH[3]}]}");
            fi;
            if ((${#vars[@]})); then
                _comp_compgen -U vars -c "$cur" ltrim_colon "${vars[@]}";
            else
                _comp_compgen_set;
            fi;
            return 0;
        else
            if [[ $cur =~ ^\$\{[#!]?[A-Za-z0-9_]*\[.*\]$ ]]; then
                _comp_compgen -c "$cur" ltrim_colon "$cur}";
                return 0;
            fi;
        fi;
    fi;
    return 1
}
_comp_compgen_xinetd_services () 
{ 
    local xinetddir=${_comp__test_xinetd_dir:-/etc/xinetd.d};
    if [[ -d $xinetddir ]]; then
        local -a svcs;
        if _comp_expand_glob svcs '$xinetddir/!($_comp_backup_glob)'; then
            _comp_compgen -U svcs -U xinetddir -- -W '"${svcs[@]#$xinetddir/}"';
        fi;
    fi
}
_comp_complete_filedir_xspec () 
{ 
    local cur prev words cword comp_args;
    _comp_initialize -- "$@" || return;
    _comp_compgen_filedir_xspec "$1"
}
_comp_complete_known_hosts () 
{ 
    local cur prev words cword comp_args;
    _comp_initialize -n : -- "$@" || return;
    local -a options=();
    [[ ${1-} == -a || ${2-} == -a ]] && options+=(-a);
    [[ ${1-} == -c || ${2-} == -c ]] && options+=(-c);
    local IFS=' 	
';
    _comp_compgen_known_hosts ${options[@]+"${options[@]}"} -- "$cur"
}
_comp_complete_load () 
{ 
    local cmd=${1:-_EmptycmD_};
    _comp_load -D -- "$cmd" && return 124
}
_comp_complete_longopt () 
{ 
    local cur prev words cword was_split comp_args;
    _comp_initialize -s -- "$@" || return;
    case "${prev,,}" in 
        --help | --usage | --version)
            return
        ;;
        --!(no-*)dir*)
            _comp_compgen -a filedir -d;
            return
        ;;
        --!(no-*)@(file|path)*)
            _comp_compgen -a filedir;
            return
        ;;
        --+([-a-z0-9_]))
            local argtype=$(LC_ALL=C $1 --help 2>&1 | command sed -ne "s|.*$prev\[\{0,1\}=[<[]\{0,1\}\([-A-Za-z0-9_]\{1,\}\).*|\1|p");
            case ${argtype,,} in 
                *dir*)
                    _comp_compgen -a filedir -d;
                    return
                ;;
                *file* | *path*)
                    _comp_compgen -a filedir;
                    return
                ;;
            esac
        ;;
    esac;
    [[ -n $was_split ]] && return;
    if [[ $cur == -* ]]; then
        _comp_compgen_split -- "$(LC_ALL=C $1 --help 2>&1 | while read -r line; do
    [[ $line =~ --[A-Za-z0-9]+([-_][A-Za-z0-9]+)*=? ]] && printf '%s\n' "${BASH_REMATCH[0]}";
done)";
        [[ ${COMPREPLY-} == *= ]] && compopt -o nospace;
    else
        if [[ $1 == *@(rmdir|chroot) ]]; then
            _comp_compgen -a filedir -d;
        else
            [[ $1 == *mkdir ]] && compopt -o nospace;
            _comp_compgen -a filedir;
        fi;
    fi
}
_comp_complete_minimal () 
{ 
    local cur prev words cword comp_args;
    _comp_initialize -- "$@" || return;
    compopt -o bashdefault -o default
}
_comp_complete_service () 
{ 
    local cur prev words cword comp_args;
    _comp_initialize -- "$@" || return;
    ((cword > 2)) && return;
    if [[ $cword -eq 1 && $prev == ?(*/)service ]]; then
        _comp_compgen_services;
        [[ -e /etc/mandrake-release ]] && _comp_compgen_xinetd_services;
    else
        local sysvdirs;
        _comp_sysvdirs || return 1;
        _comp_compgen_split -l -- "$(command sed -e 'y/|/ /' -ne 's/^.*\(U\|msg_u\)sage.*{\(.*\)}.*$/\2/p' "${sysvdirs[0]}/${prev##*/}" 2> /dev/null) start stop";
    fi
}
_comp_complete_user_at_host () 
{ 
    local cur prev words cword comp_args;
    _comp_initialize -n : -- "$@" || return;
    if [[ $cur == *@* ]]; then
        _comp_compgen_known_hosts "$cur";
    else
        _comp_compgen -- -u -S @;
        compopt -o nospace;
    fi
}
_comp_count_args () 
{ 
    local has_optarg="" has_exclude="" exclude="" glob_include="";
    local OPTIND=1 OPTARG="" OPTERR=0 _opt;
    while getopts ':a:n:i:' _opt "$@"; do
        case $_opt in 
            a)
                has_optarg=$OPTARG
            ;;
            n)
                has_exclude=set exclude+=$OPTARG
            ;;
            i)
                glob_include=$OPTARG
            ;;
            *)
                echo "bash_completion: $FUNCNAME: usage error" 1>&2;
                return 2
            ;;
        esac;
    done;
    shift "$((OPTIND - 1))";
    if [[ -n $has_exclude ]]; then
        local cword words;
        _comp__reassemble_words "$exclude<>&" words cword;
    fi;
    local i;
    REPLY=1;
    for ((i = 1; i < cword; i++))
    do
        if [[ -n $has_optarg && ${words[i]} == $has_optarg ]]; then
            ((i++));
        else
            if [[ ${words[i]} != -?* || -n $glob_include && ${words[i]} == $glob_include ]]; then
                ((REPLY++));
            else
                if [[ ${words[i]} == -- ]]; then
                    ((REPLY += cword - i - 1));
                    break;
                fi;
            fi;
        fi;
    done
}
_comp_delimited () 
{ 
    local prefix="" delimiter=$1 deduplicate=set;
    shift;
    if [[ $delimiter == -k ]]; then
        deduplicate="";
        delimiter=$1;
        shift;
    fi;
    [[ $cur == *"$delimiter"* ]] && prefix=${cur%"$delimiter"*}$delimiter;
    if [[ -n $deduplicate ]]; then
        _comp_compgen -R -- "$@";
        local -a existing;
        _comp_split -F "$delimiter" existing "$cur";
        [[ ! -n $cur || $cur == *"$delimiter" ]] || unset -v "existing[${#existing[@]}-1]";
        if ((${#COMPREPLY[@]})); then
            local x i;
            for x in ${existing+"${existing[@]}"};
            do
                for i in "${!COMPREPLY[@]}";
                do
                    if [[ $x == "${COMPREPLY[i]}" ]]; then
                        unset -v 'COMPREPLY[i]';
                        continue 2;
                    fi;
                done;
            done;
            ((${#COMPREPLY[@]})) && _comp_compgen -c "${cur##*"$delimiter"}" -- -W '"${COMPREPLY[@]}"';
        fi;
    else
        _comp_compgen -c "${cur##*"$delimiter"}" -- "$@";
    fi;
    local i;
    for i in "${!COMPREPLY[@]}";
    do
        COMPREPLY[i]="$prefix${COMPREPLY[i]}";
    done;
    [[ $delimiter != : ]] || _comp_ltrim_colon_completions "$cur"
}
_comp_deprecate_func () 
{ 
    if (($# != 3)); then
        printf 'bash_completion: %s: usage: %s DEPRECATION_VERSION OLD_NAME NEW_NAME\n' "$FUNCNAME" "$FUNCNAME";
        return 2;
    fi;
    if [[ $2 != [a-zA-Z_]*([a-zA-Z_0-9]) ]]; then
        printf 'bash_completion: %s: %s\n' "$FUNCNAME" "\$2: invalid function name '$1'" 1>&2;
        return 2;
    else
        if [[ $3 != [a-zA-Z_]*([a-zA-Z_0-9]) ]]; then
            printf 'bash_completion: %s: %s\n' "$FUNCNAME" "\$3: invalid function name '$2'" 1>&2;
            return 2;
        fi;
    fi;
    eval -- "$2() { $3 \"\$@\"; }"
}
_comp_deprecate_var () 
{ 
    if (($# != 3)); then
        printf 'bash_completion: %s: usage: %s DEPRECATION_VERSION OLD_NAME NEW_NAME\n' "$FUNCNAME" "$FUNCNAME";
        return 2;
    fi;
    if [[ $2 != [a-zA-Z_]*([a-zA-Z_0-9]) ]]; then
        printf 'bash_completion: %s: %s\n' "$FUNCNAME" "\$2: invalid variable name '$1'" 1>&2;
        return 2;
    else
        if [[ $3 != [a-zA-Z_]*([a-zA-Z_0-9]) ]]; then
            printf 'bash_completion: %s: %s\n' "$FUNCNAME" "\$3: invalid variable name '$2'" 1>&2;
            return 2;
        fi;
    fi;
    if ((BASH_VERSINFO[0] >= 5 || BASH_VERSINFO[0] == 4 && BASH_VERSINFO[1] >= 3)); then
        eval "declare -gn $2=$3";
    else
        if [[ -v $2 && ! -v $3 ]]; then
            printf -v "$3" %s "$2";
        fi;
    fi
}
_comp_dequote () 
{ 
    REPLY=();
    [[ $1 =~ $_comp_dequote__regex_safe_word ]] || return 1;
    eval "REPLY=($1)" 2> /dev/null
}
_comp_expand () 
{ 
    case ${cur-} in 
        ~*/*)
            local REPLY;
            _comp_expand_tilde "$cur";
            cur=$REPLY
        ;;
        ~*)
            _comp_compgen -v COMPREPLY tilde && eval "COMPREPLY[0]=$(printf ~%q "${COMPREPLY[0]#\~}")" && return 1
        ;;
    esac;
    return 0
}
_comp_expand_glob () 
{ 
    if (($# != 2)); then
        printf 'bash-completion: %s: unexpected number of arguments\n' "$FUNCNAME" 1>&2;
        printf 'usage: %s ARRAY_NAME PATTERN\n' "$FUNCNAME" 1>&2;
        return 2;
    else
        if [[ $1 == @(GLOBIGNORE|_*|*[^_a-zA-Z0-9]*|[0-9]*|'') ]]; then
            printf 'bash-completion: %s: invalid array name "%s"\n' "$FUNCNAME" "$1" 1>&2;
            return 2;
        fi;
    fi;
    local _original_opts=$SHELLOPTS:$BASHOPTS;
    set +o noglob;
    shopt -s nullglob;
    shopt -u failglob dotglob;
    local GLOBIGNORE=;
    eval -- "$1=()";
    eval -- "$1=($2)";
    _comp_unlocal GLOBIGNORE;
    if [[ :$_original_opts: == *:dotglob:* ]]; then
        shopt -s dotglob;
    else
        shopt -u dotglob;
    fi;
    [[ :$_original_opts: == *:nullglob:* ]] || shopt -u nullglob;
    [[ :$_original_opts: == *:failglob:* ]] && shopt -s failglob;
    [[ :$_original_opts: == *:noglob:* ]] && set -o noglob;
    eval "((\${#$1[@]}))"
}
_comp_expand_tilde () 
{ 
    REPLY=$1;
    if [[ $1 == \~* ]]; then
        printf -v REPLY '~%q' "${1#\~}";
        eval "REPLY=$REPLY";
    fi
}
_comp_get_first_arg () 
{ 
    _comp_locate_first_arg "$@" && REPLY=${words[REPLY]}
}
_comp_get_ncpus () 
{ 
    local var=NPROCESSORS_ONLN;
    [[ $OSTYPE == *@(linux|msys|cygwin)* ]] && var=_$var;
    if REPLY=$(getconf $var 2> /dev/null) && ((REPLY >= 1)); then
        return 0;
    else
        REPLY=1;
        return 1;
    fi
}
_comp_get_words () 
{ 
    local exclude="" flag i OPTIND=1;
    local cur cword words=();
    local upargs=() upvars=() vcur="" vcword="" vprev="" vwords="";
    while getopts "c:i:n:p:w:" flag "$@"; do
        case $flag in 
            [cipw])
                if [[ $OPTARG != [a-zA-Z_]*([a-zA-Z_0-9])?(\[*\]) ]]; then
                    echo "bash_completion: $FUNCNAME: -$flag: invalid variable name \`$OPTARG'" 1>&2;
                    return 1;
                fi
            ;;&
            c)
                vcur=$OPTARG
            ;;
            i)
                vcword=$OPTARG
            ;;
            n)
                exclude=$OPTARG
            ;;
            p)
                vprev=$OPTARG
            ;;
            w)
                vwords=$OPTARG
            ;;
            *)
                echo "bash_completion: $FUNCNAME: usage error" 1>&2;
                return 1
            ;;
        esac;
    done;
    while [[ $# -ge $OPTIND ]]; do
        case ${!OPTIND} in 
            cur)
                vcur=cur
            ;;
            prev)
                vprev=prev
            ;;
            cword)
                vcword=cword
            ;;
            words)
                vwords=words
            ;;
            *)
                echo "bash_completion: $FUNCNAME: \`${!OPTIND}':" "unknown argument" 1>&2;
                return 1
            ;;
        esac;
        ((OPTIND += 1));
    done;
    _comp__get_cword_at_cursor "${exclude-}" words cword cur;
    [[ -n $vcur ]] && { 
        upvars+=("$vcur");
        upargs+=(-v "$vcur" "$cur")
    };
    [[ -n $vcword ]] && { 
        upvars+=("$vcword");
        upargs+=(-v "$vcword" "$cword")
    };
    [[ -n $vprev ]] && { 
        local value="";
        ((cword >= 1)) && value=${words[cword - 1]};
        upvars+=("$vprev");
        upargs+=(-v "$vprev" "$value")
    };
    [[ -n $vwords ]] && { 
        local IFS=' 	
';
        upvars+=("$vwords");
        upargs+=(-a"${#words[@]}" "$vwords" ${words+"${words[@]}"})
    };
    ((${#upvars[@]})) && local "${upvars[@]}" && _comp_upvars "${upargs[@]}"
}
_comp_have_command () 
{ 
    PATH=$PATH:/usr/sbin:/sbin:/usr/local/sbin type "$1" &> /dev/null
}
_comp_initialize () 
{ 
    local exclude="" opt_split="" outx="" errx="" inx="";
    local flag OPTIND=1 OPTARG="" OPTERR=0;
    while getopts "n:e:o:i:s" flag "$@"; do
        case $flag in 
            n)
                exclude+=$OPTARG
            ;;
            e)
                errx=$OPTARG
            ;;
            o)
                outx=$OPTARG
            ;;
            i)
                inx=$OPTARG
            ;;
            s)
                opt_split="set";
                was_split="";
                exclude+="="
            ;;
            *)
                echo "bash_completion: $FUNCNAME: usage error" 1>&2;
                return 1
            ;;
        esac;
    done;
    shift "$((OPTIND - 1))";
    (($#)) && comp_args=("$@");
    COMPREPLY=();
    local redir='@(?(+([0-9])|{[a-zA-Z_]*([a-zA-Z_0-9])})@(>?([>|&])|<?([>&])|<<?([-<]))|&>?(>))';
    _comp_get_words -n "$exclude<>&" cur prev words cword;
    _comp_compgen_variables && return 1;
    if [[ $cur == $redir* || ${prev-} == $redir ]]; then
        local xspec;
        case $cur in 
            2'>'*)
                xspec=${errx-}
            ;;
            *'>'*)
                xspec=${outx-}
            ;;
            *'<'*)
                xspec=${inx-}
            ;;
            *)
                case $prev in 
                    2'>'*)
                        xspec=${errx-}
                    ;;
                    *'>'*)
                        xspec=${outx-}
                    ;;
                    *'<'*)
                        xspec=${inx-}
                    ;;
                esac
            ;;
        esac;
        cur=${cur##$redir};
        _comp_compgen_filedir "$xspec";
        return 1;
    fi;
    local i skip;
    for ((i = 1; i < ${#words[@]}; 1))
    do
        if [[ ${words[i]} == $redir* ]]; then
            [[ ${words[i]} == $redir ]] && skip=2 || skip=1;
            words=("${words[@]:0:i}" "${words[@]:i+skip}");
            ((i <= cword)) && ((cword -= skip));
        else
            ((i++));
        fi;
    done;
    ((cword <= 0)) && return 1;
    prev=${words[cword - 1]};
    [[ -n $opt_split ]] && _comp__split_longopt && was_split="set";
    return 0
}
_comp_load () 
{ 
    local flag_fallback_default="" IFS=' 	
';
    local OPTIND=1 OPTARG="" OPTERR=0 opt;
    while getopts ':D' opt "$@"; do
        case $opt in 
            D)
                flag_fallback_default=set
            ;;
            *)
                echo "bash_completion: $FUNCNAME: usage error" 1>&2;
                return 2
            ;;
        esac;
    done;
    shift "$((OPTIND - 1))";
    local cmd=$1 cmdname=${1##*/} dir compfile;
    local -a paths;
    [[ -n $cmdname ]] || return 1;
    local backslash=;
    if [[ $cmd == \\* ]]; then
        cmd=${cmd:1};
        $(complete -p "$cmd" 2> /dev/null || echo false) "\\$cmd" && return 0;
        backslash=\\;
    fi;
    local REPLY pathcmd origcmd=$cmd;
    if pathcmd=$(type -P "$cmd"); then
        _comp_abspath "$pathcmd";
        cmd=$REPLY;
    fi;
    local -a dirs=();
    if [[ -n ${BASH_COMPLETION_USER_DIR-} ]]; then
        _comp_split -F : paths "$BASH_COMPLETION_USER_DIR" && dirs+=("${paths[@]/%//completions}");
    else
        dirs=("${XDG_DATA_HOME:-$HOME/.local/share}/bash-completion/completions");
    fi;
    if [[ $BASH_SOURCE == */* ]]; then
        dirs+=("${BASH_SOURCE%/*}/completions");
    else
        dirs+=(./completions);
    fi;
    paths=();
    [[ $cmd == /* ]] && paths+=("${cmd%/*}");
    _comp_realcommand "$cmd" && paths+=("${REPLY%/*}");
    _comp_split -aF : paths "$PATH";
    for dir in "${paths[@]%/}";
    do
        [[ $dir == ?*/@(bin|sbin) ]] && dirs+=("${dir%/*}/share/bash-completion/completions");
    done;
    _comp_split -F : paths "${XDG_DATA_DIRS:-/usr/local/share:/usr/share}" && dirs+=("${paths[@]/%//bash-completion/completions}");
    local IFS=' 	
';
    shift;
    local i prefix compspec;
    for prefix in "" _;
    do
        for i in ${!dirs[*]};
        do
            dir=${dirs[i]};
            if [[ ! -d $dir ]]; then
                unset -v 'dirs[i]';
                continue;
            fi;
            for compfile in "$prefix$cmdname" "$prefix$cmdname.bash";
            do
                compfile="$dir/$compfile";
                if [[ -d $compfile ]]; then
                    [[ $compfile == */.?(.) ]] || echo "bash_completion: $compfile: is a directory" 1>&2;
                else
                    if [[ -e $compfile ]] && . "$compfile" "$cmd" "$@"; then
                        if compspec=$(complete -p "$cmd" 2> /dev/null); then
                            [[ -n $backslash ]] && eval "$compspec \"\$backslash\$cmd\"";
                            [[ $origcmd != */* ]] && ! complete -p "$origcmd" &> /dev/null && eval "$compspec \"\$origcmd\"";
                            return 0;
                        fi;
                        if [[ $cmdname != "$cmd" ]] && compspec=$(complete -p "$cmdname" 2> /dev/null); then
                            [[ $cmd == /* ]] && eval "$compspec \"\$cmd\"";
                            return 0;
                        fi;
                    fi;
                fi;
            done;
        done;
    done;
    [[ -v _comp_xspecs[$cmdname] || -v _xspecs[$cmdname] ]] && complete -F _comp_complete_filedir_xspec "$cmdname" "$backslash$cmdname" && return 0;
    if [[ -n $flag_fallback_default ]]; then
        complete -F _comp_complete_minimal -- "$origcmd" && return 0;
    fi;
    return 1
}
_comp_locate_first_arg () 
{ 
    local has_optarg="";
    local OPTIND=1 OPTARG="" OPTERR=0 _opt;
    while getopts ':a:' _opt "$@"; do
        case $_opt in 
            a)
                has_optarg=$OPTARG
            ;;
            *)
                echo "bash_completion: $FUNCNAME: usage error" 1>&2;
                return 2
            ;;
        esac;
    done;
    shift "$((OPTIND - 1))";
    local i;
    REPLY=;
    for ((i = 1; i < cword; i++))
    do
        if [[ -n $has_optarg && ${words[i]} == $has_optarg ]]; then
            ((i++));
        else
            if [[ ${words[i]} != -?* ]]; then
                REPLY=$i;
                return 0;
            else
                if [[ ${words[i]} == -- ]]; then
                    ((i + 1 < cword)) && REPLY=$((i + 1)) && return 0;
                    break;
                fi;
            fi;
        fi;
    done;
    return 1
}
_comp_looks_like_path () 
{ 
    [[ ${1-} == @(*/|[.~])* ]]
}
_comp_ltrim_colon_completions () 
{ 
    ((${#COMPREPLY[@]})) || return 0;
    _comp_compgen -c "$1" ltrim_colon "${COMPREPLY[@]}"
}
_comp_quote () 
{ 
    REPLY=\'${1//\'/\'\\\'\'}\'
}
_comp_quote_compgen () 
{ 
    if [[ $1 == \'* ]]; then
        REPLY=${1:1};
    else
        printf -v REPLY %q "$1";
        if [[ $REPLY == \$\'*\' ]]; then
            local value=${REPLY:2:-1};
            value=${value//'%'/%%};
            printf -v REPLY "$value";
        fi;
    fi
}
_comp_readline_variable_on () 
{ 
    [[ $(bind -v) == *$1+([[:space:]])on* ]]
}
_comp_realcommand () 
{ 
    REPLY="";
    local file;
    file=$(type -P "$1") || return $?;
    if type -p realpath > /dev/null; then
        REPLY=$(realpath "$file");
    else
        if type -p greadlink > /dev/null; then
            REPLY=$(greadlink -f "$file");
        else
            if type -p readlink > /dev/null; then
                REPLY=$(readlink -f "$file");
            else
                _comp_abspath "$file";
            fi;
        fi;
    fi
}
_comp_root_command () 
{ 
    local PATH=$PATH:/sbin:/usr/sbin:/usr/local/sbin;
    local _comp_root_command=$1;
    _comp_command
}
_comp_split () 
{ 
    local _append="" IFS=' 	
';
    local OPTIND=1 OPTARG="" OPTERR=0 _opt;
    while getopts ':alF:' _opt "$@"; do
        case $_opt in 
            a)
                _append=set
            ;;
            l)
                IFS='
'
            ;;
            F)
                IFS=$OPTARG
            ;;
            *)
                echo "bash_completion: $FUNCNAME: usage error" 1>&2;
                return 2
            ;;
        esac;
    done;
    shift "$((OPTIND - 1))";
    if (($# != 2)); then
        printf '%s\n' "bash_completion: $FUNCNAME: unexpected number of arguments" 1>&2;
        printf '%s\n' "usage: $FUNCNAME [-al] [-F SEP] ARRAY_NAME TEXT" 1>&2;
        return 2;
    else
        if [[ $1 == @(*[^_a-zA-Z0-9]*|[0-9]*|''|_*|IFS|OPTIND|OPTARG|OPTERR) ]]; then
            printf '%s\n' "bash_completion: $FUNCNAME: invalid array name '$1'" 1>&2;
            return 2;
        fi;
    fi;
    local _original_opts=$SHELLOPTS;
    set -o noglob;
    local _old_size _new_size;
    if [[ -n $_append ]]; then
        eval "$1+=()";
        eval "_old_size=\${#$1[@]}";
        eval "$1+=(\$2)";
    else
        _old_size=0;
        eval "$1=(\$2)";
    fi;
    eval "_new_size=\${#$1[@]}";
    [[ :$_original_opts: == *:noglob:* ]] || set +o noglob;
    ((_new_size > _old_size))
}
_comp_sysvdirs () 
{ 
    sysvdirs=();
    [[ -d /etc/rc.d/init.d ]] && sysvdirs+=(/etc/rc.d/init.d);
    [[ -d /etc/init.d ]] && sysvdirs+=(/etc/init.d);
    [[ -f /etc/slackware-version ]] && sysvdirs=(/etc/rc.d);
    ((${#sysvdirs[@]}))
}
_comp_try_faketty () 
{ 
    if type unbuffer &> /dev/null; then
        unbuffer -p "$@";
    else
        if script --version 2>&1 | command grep -qF util-linux; then
            script -qaefc "$*" /dev/null;
        else
            "$@";
        fi;
    fi
}
_comp_unlocal () 
{ 
    if ((BASH_VERSINFO[0] >= 5)) && shopt -q localvar_unset; then
        shopt -u localvar_unset;
        unset -v "$@";
        shopt -s localvar_unset;
    else
        unset -v "$@";
    fi
}
_comp_upvars () 
{ 
    if ! (($#)); then
        echo "bash_completion: $FUNCNAME: usage: $FUNCNAME" "[-v varname value] | [-aN varname [value ...]] ..." 1>&2;
        return 2;
    fi;
    while (($#)); do
        case $1 in 
            -a*)
                [[ -n ${1#-a} ]] || { 
                    echo "bash_completion: $FUNCNAME:" "\`$1': missing number specifier" 1>&2;
                    return 1
                };
                printf %d "${1#-a}" &> /dev/null || { 
                    echo bash_completion: "$FUNCNAME: \`$1': invalid number specifier" 1>&2;
                    return 1
                };
                [[ -n $2 ]] && unset -v "$2" && eval "$2"=\(\"\$"{@:3:${1#-a}}"\"\) && shift $((${1#-a} + 2)) || { 
                    echo bash_completion: "$FUNCNAME: \`$1${2+ }$2': missing argument(s)" 1>&2;
                    return 1
                }
            ;;
            -v)
                [[ -n $2 ]] && unset -v "$2" && eval "$2"=\"\$3\" && shift 3 || { 
                    echo "bash_completion: $FUNCNAME: $1:" "missing argument(s)" 1>&2;
                    return 1
                }
            ;;
            *)
                echo "bash_completion: $FUNCNAME: $1: invalid option" 1>&2;
                return 1
            ;;
        esac;
    done
}
_comp_userland () 
{ 
    local userland=$(uname -s);
    [[ $userland == @(Linux|GNU/*) ]] && userland=GNU;
    [[ $userland == "$1" ]]
}
_comp_variable_assignments () 
{ 
    local cur=${1-} i;
    if [[ $cur =~ ^([A-Za-z_][A-Za-z0-9_]*)=(.*)$ ]]; then
        prev=${BASH_REMATCH[1]};
        cur=${BASH_REMATCH[2]};
    else
        return 1;
    fi;
    case $prev in 
        TZ)
            cur=/usr/share/zoneinfo/$cur;
            _comp_compgen_filedir;
            if ((${#COMPREPLY[@]})); then
                for i in "${!COMPREPLY[@]}";
                do
                    if [[ ${COMPREPLY[i]} == *.tab ]]; then
                        unset -v 'COMPREPLY[i]';
                        continue;
                    else
                        if [[ -d ${COMPREPLY[i]} ]]; then
                            COMPREPLY[i]+=/;
                            compopt -o nospace;
                        fi;
                    fi;
                    COMPREPLY[i]=${COMPREPLY[i]#/usr/share/zoneinfo/};
                done;
            fi
        ;;
        TERM)
            _comp_compgen_terms
        ;;
        LANG | LC_*)
            _comp_compgen_split -- "$(locale -a 2> /dev/null)"
        ;;
        LANGUAGE)
            _comp_delimited : -W '$(locale -a 2>/dev/null)'
        ;;
        *)
            _comp_compgen_variables && return 0;
            _comp_compgen -a filedir
        ;;
    esac;
    return 0
}
_comp_xfunc () 
{ 
    local xfunc_name=$2;
    [[ $xfunc_name == _* ]] || xfunc_name=_comp_xfunc_${1//[^a-zA-Z0-9_]/_}_$xfunc_name;
    declare -F "$xfunc_name" &> /dev/null || _comp_load "$1";
    "$xfunc_name" "${@:3}"
}
_complete_as_root () 
{ 
    _comp_as_root "$@"
}
_completion_loader () 
{ 
    _comp_complete_load "$@"
}
_configured_interfaces () 
{ 
    _comp_compgen_configured_interfaces "$@"
}
_count_args () 
{ 
    local i cword words;
    _comp__reassemble_words "${1-}" words cword;
    args=1;
    for ((i = 1; i < cword; i++))
    do
        if [[ ${words[i]} != -* && ${words[i - 1]} != ${2-} || ${words[i]} == ${3-} ]]; then
            ((args++));
        fi;
    done
}
_dvd_devices () 
{ 
    _comp_compgen -a dvd_devices
}
_expand () 
{ 
    _comp_expand "$@"
}
_filedir () 
{ 
    _comp_compgen -a filedir "$@"
}
_filedir_xspec () 
{ 
    _comp_complete_filedir_xspec "$@"
}
_fstypes () 
{ 
    _comp_compgen -a fstypes
}
_get_comp_words_by_ref () 
{ 
    _comp_get_words "$@"
}
_get_cword () 
{ 
    local LC_CTYPE=C;
    local cword words;
    _comp__reassemble_words "${1-}" words cword;
    if [[ -n ${2-} && -n ${2//[^0-9]/} ]]; then
        printf "%s" "${words[cword - $2]}";
    else
        if ((${#words[cword]} == 0 && COMP_POINT == ${#COMP_LINE})); then
            :;
        else
            local i;
            local cur=$COMP_LINE;
            local index=$COMP_POINT;
            for ((i = 0; i <= cword; ++i))
            do
                while [[ ${#cur} -ge ${#words[i]} && ${cur:0:${#words[i]}} != "${words[i]}" ]]; do
                    cur=${cur:1};
                    ((index > 0)) && ((index--));
                done;
                if ((i < cword)); then
                    local old_size=${#cur};
                    cur=${cur#"${words[i]}"};
                    local new_size=${#cur};
                    ((index -= old_size - new_size));
                fi;
            done;
            if [[ ${words[cword]:0:${#cur}} != "$cur" ]]; then
                printf "%s" "${words[cword]}";
            else
                printf "%s" "${cur:0:index}";
            fi;
        fi;
    fi
}
_get_first_arg () 
{ 
    local i;
    arg=;
    for ((i = 1; i < COMP_CWORD; i++))
    do
        if [[ ${COMP_WORDS[i]} != -* ]]; then
            arg=${COMP_WORDS[i]};
            break;
        fi;
    done
}
_get_pword () 
{ 
    if ((COMP_CWORD >= 1)); then
        _get_cword "${@-}" 1;
    fi
}
_gids () 
{ 
    _comp_compgen_gids "$@"
}
_have () 
{ 
    _comp_have_command "$@"
}
_init_completion () 
{ 
    local was_split;
    _comp_initialize "$@";
    local rc=$?;
    local flag OPTIND=1 OPTARG="" OPTERR=0;
    while getopts "n:e:o:i:s" flag "$@"; do
        case $flag in 
            [neoi])

            ;;
            s)
                if [[ -n $was_split ]]; then
                    split=true;
                else
                    split=false;
                fi;
                break
            ;;
        esac;
    done;
    return "$rc"
}
_installed_modules () 
{ 
    _comp_compgen_inserted_kernel_modules "$@"
}
_ip_addresses () 
{ 
    _comp_compgen_ip_addresses "$@"
}
_kernel_versions () 
{ 
    _comp_compgen_kernel_versions "$@"
}
_known_hosts () 
{ 
    _comp_complete_known_hosts "$@"
}
_known_hosts_real () 
{ 
    _comp_compgen_known_hosts "$@"
}
_longopt () 
{ 
    _comp_complete_longopt "$@"
}
_mac_addresses () 
{ 
    _comp_compgen_mac_addresses "$@"
}
_minimal () 
{ 
    _comp_complete_minimal "$@"
}
_modules () 
{ 
    _comp_compgen_kernel_modules "$@"
}
_ncpus () 
{ 
    local REPLY;
    _comp_get_ncpus;
    printf %s "$REPLY"
}
_parse_help () 
{ 
    local -a args;
    if [[ $1 == - ]]; then
        args=(-);
    else
        local REPLY opt IFS=' 	
';
        _comp_dequote "$1";
        _comp_split opt "${2:---help}";
        args=(-c "$REPLY" ${opt[@]+"${opt[@]}"});
    fi;
    local -a REPLY=();
    _comp_compgen -Rv REPLY help "${args[@]}" || return 1;
    ((${#REPLY[@]})) && printf '%s\n' "${REPLY[@]}";
    return 0
}
_parse_usage () 
{ 
    local -a args;
    if [[ $1 == - ]]; then
        args=(-);
    else
        local REPLY opt IFS=' 	
';
        _comp_dequote "$1";
        _comp_split opt "${2:---usage}";
        args=(-c "$REPLY" ${opt[@]+"${opt[@]}"});
    fi;
    local -a REPLY=();
    _comp_compgen -Rv REPLY usage "${args[@]}" || return 1;
    ((${#REPLY[@]})) && printf '%s\n' "${REPLY[@]}";
    return 0
}
_pci_ids () 
{ 
    _comp_compgen -a pci_ids
}
_pgids () 
{ 
    _comp_compgen_pgids "$@"
}
_pids () 
{ 
    _comp_compgen_pids "$@"
}
_pnames () 
{ 
    _comp_compgen_pnames "$@"
}
_poetry_9134073ca275ed5f_complete () 
{ 
    local cur script coms opts com;
    COMPREPLY=();
    _get_comp_words_by_ref -n : cur words;
    if [[ $(type -t ${words[0]}) == "alias" ]]; then
        script=$(alias ${words[0]} | sed -E "s/alias ${words[0]}='(.*)'/\1/");
    else
        script=${words[0]};
    fi;
    for word in ${words[@]:1};
    do
        if [[ $word != -* ]]; then
            com=$word;
            break;
        fi;
    done;
    if [[ ${cur} == --* ]]; then
        opts="--ansi --directory --help --no-ansi --no-cache --no-interaction --no-plugins --quiet --verbose --version";
        case "$com" in 
            about)
                opts="${opts} "
            ;;
            add)
                opts="${opts} --allow-prereleases --dev --dry-run --editable --extras --group --lock --optional --platform --python --source"
            ;;
            build)
                opts="${opts} --format --output"
            ;;
            'cache clear')
                opts="${opts} --all"
            ;;
            'cache list')
                opts="${opts} "
            ;;
            check)
                opts="${opts} --lock"
            ;;
            config)
                opts="${opts} --list --local --unset"
            ;;
            'debug info')
                opts="${opts} "
            ;;
            'debug resolve')
                opts="${opts} --extras --install --python --tree"
            ;;
            'env info')
                opts="${opts} --executable --path"
            ;;
            'env list')
                opts="${opts} --full-path"
            ;;
            'env remove')
                opts="${opts} --all"
            ;;
            'env use')
                opts="${opts} "
            ;;
            export)
                opts="${opts} --all-extras --dev --extras --format --only --output --with --with-credentials --without --without-hashes --without-urls"
            ;;
            help)
                opts="${opts} "
            ;;
            init)
                opts="${opts} --author --dependency --description --dev-dependency --license --name --python"
            ;;
            install)
                opts="${opts} --all-extras --compile --dry-run --extras --no-dev --no-directory --no-root --only --only-root --remove-untracked --sync --with --without"
            ;;
            list)
                opts="${opts} "
            ;;
            lock)
                opts="${opts} --check --no-update"
            ;;
            new)
                opts="${opts} --name --readme --src"
            ;;
            publish)
                opts="${opts} --build --cert --client-cert --dist-dir --dry-run --password --repository --skip-existing --username"
            ;;
            remove)
                opts="${opts} --dev --dry-run --group --lock"
            ;;
            run)
                opts="${opts} "
            ;;
            search)
                opts="${opts} "
            ;;
            'self add')
                opts="${opts} --allow-prereleases --dry-run --editable --extras --source"
            ;;
            'self install')
                opts="${opts} --dry-run --sync"
            ;;
            'self lock')
                opts="${opts} --check --no-update"
            ;;
            'self remove')
                opts="${opts} --dry-run"
            ;;
            'self show')
                opts="${opts} --addons --latest --outdated --tree"
            ;;
            'self show plugins')
                opts="${opts} "
            ;;
            'self update')
                opts="${opts} --dry-run --preview"
            ;;
            shell)
                opts="${opts} "
            ;;
            show)
                opts="${opts} --all --latest --no-dev --only --outdated --top-level --tree --why --with --without"
            ;;
            'source add')
                opts="${opts} --default --priority --secondary"
            ;;
            'source remove')
                opts="${opts} "
            ;;
            'source show')
                opts="${opts} "
            ;;
            update)
                opts="${opts} --dry-run --lock --no-dev --only --sync --with --without"
            ;;
            version)
                opts="${opts} --dry-run --next-phase --short"
            ;;
        esac;
        COMPREPLY=($(compgen -W "${opts}" -- ${cur}));
        __ltrim_colon_completions "$cur";
        return 0;
    fi;
    if [[ $cur == $com ]]; then
        coms="about add build 'cache clear' 'cache list' check config 'debug info' 'debug resolve' 'env info' 'env list' 'env remove' 'env use' export help init install list lock new publish remove run search 'self add' 'self install' 'self lock' 'self remove' 'self show' 'self show plugins' 'self update' shell show 'source add' 'source remove' 'source show' update version";
        COMPREPLY=($(compgen -W "${coms}" -- ${cur}));
        __ltrim_colon_completions "$cur";
        return 0;
    fi
}
_python_argcomplete_global () 
{ 
    if [[ -n "${ZSH_VERSION-}" ]]; then
        setopt local_options BASH_REMATCH;
    fi;
    local _BASH_REMATCH="";
    local executable="";
    local req_argv=();
    if [[ -z "${ZSH_VERSION-}" ]]; then
        executable=$1;
        req_argv=("" "${COMP_WORDS[@]:1}");
        __python_argcomplete_expand_tilde_by_ref executable;
    else
        executable="${words[1]}";
        __python_argcomplete_expand_tilde_by_ref executable;
        req_argv=("${words[@]:1}");
    fi;
    local ARGCOMPLETE=0;
    if [[ "$executable" == python* ]] || [[ "$executable" == pypy* ]]; then
        if [[ "${req_argv[1]}" == -m ]]; then
            if __python_argcomplete_run "$executable" -m argcomplete._check_module "${req_argv[2]}"; then
                ARGCOMPLETE=3;
            else
                return;
            fi;
        fi;
        if [[ $ARGCOMPLETE == 0 ]]; then
            local potential_path="${req_argv[1]}";
            __python_argcomplete_expand_tilde_by_ref potential_path;
            if [[ -f "$potential_path" ]] && __python_argcomplete_scan_head_noerr "$potential_path" magic_string; then
                req_argv[1]="$potential_path";
                ARGCOMPLETE=2;
            else
                return;
            fi;
        fi;
    else
        if __python_argcomplete_which "$executable" > /dev/null 2>&1; then
            local SCRIPT_NAME=$(__python_argcomplete_which "$executable");
            __python_argcomplete_scan_head_noerr "$SCRIPT_NAME" interpreter;
            if ( __python_argcomplete_which pyenv && [[ "$SCRIPT_NAME" = $(pyenv root)/shims/* ]] ) > /dev/null 2>&1; then
                local SCRIPT_NAME=$(pyenv which "$executable");
            fi;
            if ( __python_argcomplete_which asdf && __python_argcomplete_scan_head_noerr "$SCRIPT_NAME" asdf ) > /dev/null 2>&1; then
                local SCRIPT_NAME=$(asdf which "$executable");
            fi;
            if __python_argcomplete_scan_head_noerr "$SCRIPT_NAME" magic_string; then
                ARGCOMPLETE=1;
            else
                if __python_argcomplete_scan_head_noerr "$SCRIPT_NAME" interpreter; then
                    __python_argcomplete_upshift_bash_rematch;
                    local interpreter="${_BASH_REMATCH[2]}";
                    if [[ -n "${ZSH_VERSION-}" ]]; then
                        interpreter=($=interpreter);
                    else
                        interpreter=($interpreter);
                    fi;
                    if ( __python_argcomplete_scan_head_noerr "$SCRIPT_NAME" easy_install && "${interpreter[@]}" "$(__python_argcomplete_which python-argcomplete-check-easy-install-script)" "$SCRIPT_NAME" ) > /dev/null 2>&1; then
                        ARGCOMPLETE=1;
                    else
                        if __python_argcomplete_run "${interpreter[@]}" -m argcomplete._check_console_script "$SCRIPT_NAME"; then
                            ARGCOMPLETE=1;
                        fi;
                    fi;
                fi;
            fi;
        fi;
    fi;
    if [[ $ARGCOMPLETE != 0 ]]; then
        local IFS='';
        if [[ -n "${ZSH_VERSION-}" ]]; then
            local completions;
            completions=($(IFS="$IFS" COMP_LINE="$BUFFER" COMP_POINT="$CURSOR" _ARGCOMPLETE=$ARGCOMPLETE _ARGCOMPLETE_SHELL="zsh" _ARGCOMPLETE_SUPPRESS_SPACE=1 __python_argcomplete_run "$executable" "${(@)req_argv[1, ${ARGCOMPLETE}-1]}"));
            local nosort=();
            local nospace=();
            if is-at-least 5.8; then
                nosort=(-o nosort);
            fi;
            if [[ "${completions-}" =~ ([^\\]): && "${BASH_REMATCH[2]}" =~ [=/:] ]]; then
                nospace=(-S '');
            fi;
            _describe "$executable" completions "${nosort[@]}" "${nospace[@]}";
        else
            COMPREPLY=($(IFS="$IFS" COMP_LINE="$COMP_LINE" COMP_POINT="$COMP_POINT" COMP_TYPE="$COMP_TYPE" _ARGCOMPLETE_COMP_WORDBREAKS="$COMP_WORDBREAKS" _ARGCOMPLETE=$ARGCOMPLETE _ARGCOMPLETE_SHELL="bash" _ARGCOMPLETE_SUPPRESS_SPACE=1 __python_argcomplete_run "$executable" "${req_argv[@]:1:${ARGCOMPLETE}-1}"));
            if [[ $? != 0 ]]; then
                unset COMPREPLY;
            else
                if [[ "${COMPREPLY-}" =~ [=/:]$ ]]; then
                    compopt -o nospace;
                fi;
            fi;
        fi;
    else
        if [[ -n "${ZSH_VERSION-}" ]]; then
            _default;
        else
            type -t _completion_loader | grep -q 'function' && _completion_loader "$@";
        fi;
    fi
}
_quote_readline_by_ref () 
{ 
    [[ $2 == REPLY ]] || local REPLY;
    _comp_quote_compgen "$1";
    [[ $2 == REPLY ]] || printf -v "$2" %s "$REPLY"
}
_realcommand () 
{ 
    local REPLY;
    _comp_realcommand "$1";
    local rc=$?;
    printf "%s\n" "$REPLY";
    return $rc
}
_rl_enabled () 
{ 
    _comp_readline_variable_on "$@"
}
_root_command () 
{ 
    _comp_root_command "$@"
}
_service () 
{ 
    _comp_complete_service "$@"
}
_services () 
{ 
    _comp_compgen_services "$@"
}
_shells () 
{ 
    _comp_compgen -a shells
}
_signals () 
{ 
    _comp_compgen_signals "$@"
}
_sysvdirs () 
{ 
    _comp_sysvdirs "$@"
}
_terms () 
{ 
    _comp_compgen -a terms
}
_tilde () 
{ 
    ! _comp_compgen -c "$1" tilde
}
_uids () 
{ 
    _comp_compgen_uids "$@"
}
_upvar () 
{ 
    echo "bash_completion: $FUNCNAME: deprecated function," "use _comp_upvars instead" 1>&2;
    if unset -v "$1"; then
        if (($# == 2)); then
            eval "$1"=\"\$2\";
        else
            eval "$1"=\(\"\$"{@:2}"\"\);
        fi;
    fi
}
_upvars () 
{ 
    _comp_upvars "$@"
}
_usb_ids () 
{ 
    _comp_compgen -a usb_ids
}
_user_at_host () 
{ 
    _comp_complete_user_at_host "$@"
}
_usergroup () 
{ 
    _comp_compgen_usergroups "$@"
}
_userland () 
{ 
    _comp_userland "$@"
}
_variables () 
{ 
    _comp_compgen_variables "$@"
}
_xfunc () 
{ 
    _comp_xfunc "$@"
}
_xinetd_services () 
{ 
    _comp_compgen_xinetd_services "$@"
}
command_not_found_handle () 
{ 
    local runcnf=1;
    local retval=127;
    [[ $- == *"i"* ]] || runcnf=0;
    [[ ! -S /run/dbus/system_bus_socket ]] && runcnf=0;
    [[ ! -x '/usr/libexec/packagekitd' ]] && runcnf=0;
    [[ -n ${COMP_CWORD-} ]] && runcnf=0;
    [[ ! -x '/usr/libexec/pk-command-not-found' ]] && runcnf=0;
    if [ $runcnf -eq 1 ]; then
        '/usr/libexec/pk-command-not-found' "$@";
        retval=$?;
    else
        if [[ -n "${BASH_VERSION-}" ]]; then
            printf 'bash: %s%s\n' "${1:+$1: }" "$(gettext PackageKit 'command not found')" 1>&2;
        fi;
    fi;
    return $retval
}
dequote () 
{ 
    local REPLY;
    _comp_dequote "$1";
    local rc=$?;
    printf %s "$REPLY";
    return $rc
}
gawklibpath_append () 
{ 
    [ -z "$AWKLIBPATH" ] && AWKLIBPATH=`gawk 'BEGIN {print ENVIRON["AWKLIBPATH"]}'`;
    export AWKLIBPATH="$AWKLIBPATH:$*"
}
gawklibpath_default () 
{ 
    unset AWKLIBPATH;
    export AWKLIBPATH=`gawk 'BEGIN {print ENVIRON["AWKLIBPATH"]}'`
}
gawklibpath_prepend () 
{ 
    [ -z "$AWKLIBPATH" ] && AWKLIBPATH=`gawk 'BEGIN {print ENVIRON["AWKLIBPATH"]}'`;
    export AWKLIBPATH="$*:$AWKLIBPATH"
}
gawkpath_append () 
{ 
    [ -z "$AWKPATH" ] && AWKPATH=`gawk 'BEGIN {print ENVIRON["AWKPATH"]}'`;
    export AWKPATH="$AWKPATH:$*"
}
gawkpath_default () 
{ 
    unset AWKPATH;
    export AWKPATH=`gawk 'BEGIN {print ENVIRON["AWKPATH"]}'`
}
gawkpath_prepend () 
{ 
    [ -z "$AWKPATH" ] && AWKPATH=`gawk 'BEGIN {print ENVIRON["AWKPATH"]}'`;
    export AWKPATH="$*:$AWKPATH"
}
prompt_color () 
{ 
    if [ -n "${1:+1}" ]; then
        PROMPT_COLOR="$1";
    else
        if [ "$USER" = "root" ]; then
            PROMPT_COLOR=35;
        else
            PROMPT_COLOR=32;
        fi;
    fi
}
prompt_container () 
{ 
    if [ -n "$container" ]; then
        eval local $(grep "\(^ID=\|VERSION_ID\|VARIANT_ID\)" /etc/os-release);
        PROMPT_USERHOST=" $ID-$VARIANT_ID$VERSION_ID";
    else
        if [ "$HOSTNAME" = "fedora" -a "$1" = "$USER" ]; then
            unset PROMPT_USERHOST;
        fi;
    fi
}
prompt_default () 
{ 
    prompt_default_color "$1";
    prompt_default_format
}
prompt_default_color () 
{ 
    prompt_color "$1";
    prompt_default_highlight;
    unset PROMPT_DIR_COLOR
}
prompt_default_format () 
{ 
    PROMPT_USERHOST='\u@\h';
    PROMPT_SEPARATOR=':';
    PROMPT_DIRECTORY='\w';
    PROMPT_START='';
    PROMPT_END=''
}
prompt_default_highlight () 
{ 
    if [ "$DESKTOP_SESSION" = "gnome" ]; then
        prompt_highlight "${1:-1}";
    else
        unset PROMPT_HIGHLIGHT;
    fi
}
prompt_dir_color () 
{ 
    if [ -n "${1:+1}" ]; then
        PROMPT_DIR_COLOR="$1";
    else
        unset PROMPT_DIR_COLOR;
    fi
}
prompt_highlight () 
{ 
    PROMPT_HIGHLIGHT=${1:-1}
}
prompt_no_color () 
{ 
    unset PROMPT_COLOR;
    unset PROMPT_DIR_COLOR
}
prompt_no_highlight () 
{ 
    unset PROMPT_HIGHLIGHT
}
prompt_os_color () 
{ 
    if [ -z "$ANSI_COLOR" ]; then
        eval local $(grep ANSI_COLOR /etc/os-release);
    fi;
    PROMPT_COLOR="$ANSI_COLOR${1:+;$1}"
}
prompt_plain () 
{ 
    prompt_no_color;
    prompt_no_highlight
}
prompt_reset_traditional_ps1 () 
{ 
    PS1="[\u@\h \W]\\$ "
}
prompt_setup_color_ps1 () 
{ 
    local colorpre='\[\e[';
    local colorsuf='m\]';
    local colorreset="${colorpre}0${colorsuf}";
    PS1='${PROMPT_START@P}'"${colorpre}"'${PROMPT_COLOR}${PROMPT_HIGHLIGHT:+;$PROMPT_HIGHLIGHT}'"${colorsuf}"'${PROMPT_USERHOST@P}'"${colorreset}"'${PROMPT_SEPARATOR@P}'"${colorpre}"'${PROMPT_DIR_COLOR-${PROMPT_COLOR}}${PROMPT_HIGHLIGHT:+;$PROMPT_HIGHLIGHT}'"${colorsuf}"'${PROMPT_DIRECTORY@P}'"${colorreset}"'${PROMPT_END@P}\$'"${colorreset} "
}
prompt_traditional () 
{ 
    prompt_plain;
    prompt_traditional_format
}
prompt_traditional_format () 
{ 
    PROMPT_USERHOST='\u@\h';
    PROMPT_SEPARATOR=' ';
    PROMPT_DIRECTORY='\W';
    PROMPT_START='[';
    PROMPT_END=']'
}
quote () 
{ 
    local quoted=${1//\'/\'\\\'\'};
    printf "'%s'" "$quoted"
}
quote_readline () 
{ 
    local REPLY;
    _comp_quote_compgen "$1";
    printf %s "$REPLY"
}
